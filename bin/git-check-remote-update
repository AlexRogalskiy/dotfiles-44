#!/bin/bash
#
#  Check git remote update info in git repositories.
#
#    Usage:
#      $ git-check-remote-update [directory...|target list file]
#

if ! type git > /dev/null 2>&1; then
    echo 'Error: Git is not installed' 2>&1
    exit 1
fi

## Common
get_remote_update_info(){
    local remote_name=${1:-origin}
    git remote show "$remote_name" \
        | tail -1 | sed 's/.*\((.*)\)/\1/' | tr '\n' ' ' \
        && git remote -v | head -1 | tr '\t' ' ' | cut -d' ' -f 2
}

colorize_update_info() {
    local status=$(echo "$1" | sed 's/^(\(.*\)) .*/\1/g')
    if [ "$status" != "up to date" ]; then
        status="\033[0;31m$status\033[0;39m"
    fi
    echo "($status) $(echo "$1" | sed 's/^(.*) //g')"
}

## Submodule
print_sub_update_info() {
    (
        cd "$1"
        update_info=$(colorize_update_info "$(get_remote_update_info)")
        echo -e " - $update_info [$1]"
    )
}

submodule_update_info() {
    (
        cd "$(git rev-parse --show-toplevel)" >/dev/null 2>&1;
        local -a submodule_dirs
        IFS=$'\n' submodule_dirs=($(git submodule | cut -d ' ' -f 3 | sed 's/(.*)$//'))
        if [ -z "$submodule_dirs" ]; then
            return 0
        fi
        for dir in "${submodule_dirs[@]}"; do
            print_sub_update_info "$dir"
        done
    )
}

## Repository
remote_update_info () {
    local update_info
    # HEAD branch (e.g. refs/heads/<branch-name>)
    local head_branch=$(git symbolic-ref HEAD)
    if [ -z "$head_branch" ]; then
        local prehash=$(git rev-parse --short HEAD)
        update_info="Not on any branch : prehash=$prehash"
    else
        # Retrieve brach name (like master) from HEAD branch
        local branch=$(echo "$head_branch" | sed -E s/^.\{11\}//g)
        # The remote name of HEAD branch (e.g. origin)
        local remote_name=$(git config branch."${branch}".remote)
        if [ -z "$remote_name" ]; then
            update_info='No remote repository'
            return 1
        else
            update_info=$(get_remote_update_info "$remote_name")
            update_info=$(colorize_update_info "$update_info")
        fi
    fi
    local toplevel_path=$(git rev-parse --show-toplevel)
    echo -e "$update_info [$toplevel_path]"
}

## Root function
print_update_info() {
    (
        cd "$1"
        if [ "$(git rev-parse --is-inside-work-tree 2> /dev/null)" != "true" ]; then
            return 1
        fi
        remote_update_info
        submodule_update_info
    )
}

### Main ###

if [ $# -lt 1 ]; then
    echo '## git remote show xxxx'
    print_update_info '.'
    exit 0
fi

if [ $# -eq 1 -a -f "$1" ]; then
    echo "Read file \"${1}\"..."
    echo '## git remote show xxxx'
    for dir in $(cat "$1"); do
        dir=$(echo "$dir" | sed "s%^~%$HOME%")
        [ -d "$dir" ] || continue
        print_update_info "$dir"
    done
    exit 0
fi

echo '## git remote show xxxx'
for root_dir in "$@"; do
    [ -d "$root_dir" ] || continue
    print_update_info "$root_dir"
done

