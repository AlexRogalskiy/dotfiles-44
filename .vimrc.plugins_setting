"-------------------------------------------------------------------------------
"  .vimrc.plugins_setting
"
"   Plugins settings
"
"-------------------------------------------------------------------------------

" === accelerated-jk {{{
nmap <silent>j <Plug>(accelerated_jk_gj)
nmap gj j
nmap <silent>k <Plug>(accelerated_jk_gk)
nmap gk k
" }}}

" === accelerated-smooth-scroll {{{
" let g:ac_smooth_scroll_enable_accelerating = 0

if has('gui_running')
  let g:ac_smooth_scroll_du_sleep_time_msec = 5
  let g:ac_smooth_scroll_fb_sleep_time_msec = 5
else
  let g:ac_smooth_scroll_du_sleep_time_msec = 3
  let g:ac_smooth_scroll_fb_sleep_time_msec = 3
endif
" let g:ac_smooth_scroll_skip_redraw_line_size = 0

" let g:ac_smooth_scroll_max_limit_msec = 300
let g:ac_smooth_scroll_min_limit_msec = 80
" }}}

" === anzu {{{
nmap <silent><expr> n '<Plug>(anzu-n-with-echo):normal! zz<cr>'
nmap <silent><expr> N '<Plug>(anzu-N-with-echo):normal! zz<cr>'
nmap <silent><expr> * '<Plug>(anzu-star-with-echo):normal! N<cr>'
nmap <silent><expr> # '<Plug>(anzu-sharp-with-echo):normal! N<cr>'

nmap <silent><expr> g* 'g*<Plug>(anzu-update-search-status-with-echo):normal! N<cr>'
" }}}

" === ag.vim {{{
"  :Ag [options] {pattern} [{directory}]
"  :bufdo AgAdd {pattern}
"  :LAg, LAgAdd
"  :AgFile
"  :AgHelp
"
"  If [!] is not given the first error is jumped to.
"
"   o    to open (same as enter)
"   go   to preview file (open but maintain focus on ack.vim results)
"   t    to open in new tab
"   T    to open in new tab silently
"   h    to open in horizontal split
"   H    to open in horizontal split silently
"   v    to open in vertical split
"   gv   to open in vertical split silently
"   q    to close the quickfix window
" -------------------------------------------------
" フォーマット
let g:agprg="ag -S --nogroup --column"
"}}}

" === autodate.vim {{{
"  タイムスタンプの挿入 - 形式 Last Change:ドット
"  Kaoriya版ではデフォルト有効
" -------------------------------------------------
" フォーマット
"let autodate_format="%Y/%m/%d %H:%M:%S"
let autodate_format = '%d %3m %Y'
let autodate_keyword_pre = 'Last \%(Change\|Modified\):'
" }}}

" === changelog.vim {{{
" vim標準機能で ft=changelog のときのみ動作する
"   <Leader>o : changelogエントリ追加
" -------------------------------------------------
autocmd MyAutoCmd BufNewFile,BufRead *.changelog setf changelog
let g:changelog_timeformat = "%Y-%m-%d"
let g:changelog_username = 'Yonchu '
" }}}

" === closetag.vim {{{
" <C-_> 閉じタグ入力
let g:closetag_html_style = 1
" }}}

" === coffee-script {{{
"autocmd MyAutoCmd BufWritePost *.coffee silent CoffeeMake! -cb | cwindow | redraw!
"autocmd MyAutoCmd BufWritePost *.coffee :CoffeeCompile watch vert
" }}}

" === eregex.vim {{{
"nnoremap / :M/
"nnoremap ? :M?
"nnoremap <Leader>/ /
"nnoremap <Leader>? ?
" }}}

" === errormarker.vim {{{
"let g:errormarker_disablemappings = 1
"let g:loaded_errormarker = 1
"nmap <silent> <unique> <Leader>cc :ErrorAtCursor<CR>
" }}}

" === foldCC {{{
let g:foldCCtext_enable_autofdc_adjuster = 1
let g:foldCCtext_head = '">>> "'
" set foldtext=FoldCCtext()
autocmd MyAutoCmd FileType *
      \   if &filetype !=# 'help' && exists('*FoldCCtext()')
      \ |   setlocal foldtext=foldCC#foldtext()
      \ | endif
" }}}

" === fontzoom.vim {{{
if has('gui_running')
  nmap + <Plug>(fontzoom-larger)
  nmap _ <Plug>(fontzoom-smaller)
endif
" }}}

" === Fugitive.vim {{{
" http://d.hatena.ne.jp/cohama/20120317/1331978764
" http://yuku-tech.hatenablog.com/entry/20110427/1303868482
" 現在のソースの変更点をvimdiffで表示
nnoremap <Space>gd :<C-u>Gdiff<cr>
" 新しい窓を作ってgit statusを表示
nnoremap <Space>gs :<C-u>Gstatus<cr>GM
" gitlogを表示
nnoremap <Space>gl :<C-u>Glog<cr>
" 現在開いているソースをgit add
nnoremap <Space>ga :<C-u>Gwrite<cr>
" staged なファイルがあれば git commit なければ git status
nnoremap <Space>gc :<C-u>Gcommit -v<cr>
" git commit --amend
nnoremap <Space>gC :<C-u>Git commit -v --amend<cr>
" 現在のソースをgit blame。vimが色づけしてくれる
nnoremap <Space>gb :<C-u>Gblame<cr>
" git-now
nnoremap <Space>gn :<C-u>w<CR>:Git now<CR>
nnoremap <Space>gN :<C-u>w<CR>:Git now --all<CR>
" }}}

" === gitgutter {{{
nnoremap <silent> ]v :GitGutterNextHunk<CR>
nnoremap <silent> [v :GitGutterPrevHunk<CR>
" }}}

" === Gitv {{{
" http://d.hatena.ne.jp/cohama/20120417/1334679297
" ブラウザモードで開く場合の画面分割方向
let g:Gitv_OpenHorizontal = 0
" Gitvを起動
nnoremap <Space>gv :<C-u>Gitv --all<cr>
nnoremap <Space>gV :<C-u>Gitv! --all<cr>
vnoremap <Space>gV :<C-u>Gitv! --all<cr>

" http://d.hatena.ne.jp/cohama/20130517/1368806202
function! s:gitv_get_current_hash()
  return matchstr(getline('.'), '\[\zs.\{7\}\ze\]$')
endfunction

autocmd MyAutoCmd FileType gitv call s:my_gitv_settings()
function! s:my_gitv_settings()
  setlocal iskeyword+=/,-,.
  " カーソル下のブランチ名で checkout
  " ブランチ間移動 r/R
  nnoremap <silent><buffer> C :<C-u>Git checkout <C-r><C-w><CR>

  " カーソル位置のコミットに対する操作
  nnoremap <buffer> <Space>rb :<C-u>Git rebase <C-r>=GitvGetCurrentHash()<CR><Space>
  nnoremap <buffer> <Space>R :<C-u>Git revert <C-r>=GitvGetCurrentHash()<CR><CR>
  nnoremap <buffer> <Space>h :<C-u>Git cherry-pick <C-r>=GitvGetCurrentHash()<CR><CR>
  nnoremap <buffer> <Space>rh :<C-u>Git reset --hard <C-r>=GitvGetCurrentHash()<CR>

  nnoremap <silent><buffer> T :<C-u>windo call <SID>toggle_git_folding()<CR>1<C-w>w
endfunction

function! s:toggle_git_folding()
  if &filetype ==# 'git'
    setlocal foldenable!
  endif
endfunction
" }}}

" === git-vim {{{
" http://deris.hatenablog.jp/entry/2013/05/10/003430
" https://gist.github.com/deris/5548058
" Inspired by ujihisa's vimrc
function! s:GitLogViewer()
  " vnewだとコミットメッセージが切れてしまうのでnew
  NeoBundleSource git-vim
  new
  VimProcRead git log -u 'ORIG_HEAD..HEAD'
  set filetype=git-log.git-diff
  setlocal foldmethod=expr
  setlocal foldexpr=getline(v:lnum)=~'^commit'?'>1':getline(v:lnum+1)=~'^commit'?'<1':'='
  setlocal foldtext=FoldTextOfGitLog()
  setlocal readonly
endfunction
command! GitLogViewer call s:GitLogViewer()
command! Glv call s:GitLogViewer()

" q で強制的にwindowを閉じる
autocmd MyAutoCmd FileType git-log.git-diff
      \ nnoremap <buffer><silent> q :<C-u>q!<cr>

" git log表示時の折りたたみ用
function! FoldTextOfGitLog()
  let month_map = {
    \ 'Jan' : '01',
    \ 'Feb' : '02',
    \ 'Mar' : '03',
    \ 'Apr' : '04',
    \ 'May' : '05',
    \ 'Jun' : '06',
    \ 'Jul' : '07',
    \ 'Aug' : '08',
    \ 'Sep' : '09',
    \ 'Oct' : '10',
    \ 'Nov' : '11',
    \ 'Dec' : '12',
    \ }

  if getline(v:foldstart) !~ '^commit'
    return getline(v:foldstart)
  endif

  if getline(v:foldstart + 1) =~ '^Author:'
    let author_lnum = v:foldstart + 1
  elseif getline(v:foldstart + 2) =~ '^Author:'
    " commitの次の行がMerge:の場合があるので
    let author_lnum = v:foldstart + 2
  else
    " commitの下2行がどちらもAuthor:で始まらなければ諦めて終了
    return getline(v:foldstart)
  endif

  let date_lnum = author_lnum + 1
  let message_lnum = date_lnum + 2

  let author = matchstr(getline(author_lnum), '^Author: \zs.*\ze <.\{-}>')
  let date = matchlist(getline(date_lnum), ' \(\a\{3}\) \(\d\{1,2}\) \(\d\{2}:\d\{2}:\d\{2}\) \(\d\{4}\)')
  let message = getline(message_lnum)

  let month = date[1]
  let day = printf('%02s', date[2])
  let time = date[3]
  let year = date[4]

  let datestr = join([year, month_map[month], day], '-')

  return join([datestr, time, author, message], ' ')
endfunction

" }}}

" === grep.vim {{{
let bundle = neobundle#get('grep.vim')
function! bundle.hooks.on_source(bundle)
  " MacのxargsではRgrepがエラーになる
  if has('mac')
    if executable('gxargs')
      let Grep_Xargs_Path = 'gxargs'
    else
      let Grep_Find_Use_Xargs = 0
    endif
  endif
  " デフォルトで設定されるオプション
  "  -i 大文字小文字を区別しない
  "  -n 各行の先頭にファイルの行番号を表示します
  "  -H ファイル名を表示
  "  -E オプションは、拡張正規表現を使用する場合に指定
  "     fgrep 正規表現を使わない検索
  "     egrep 正規表現を使った検索 -E と同じ
  "  -I バイナリ検索除外
  let Grep_Default_Options = '-niE'

  " 検索外のディレクトリ、ファイルパターン
  let Grep_Skip_Dirs = '.svn .git .hg'
  let Grep_Skip_Files = '*.bak *~'
endfunction
unlet bundle

" :Gb <args> でGrepBufferする
command! -nargs=1 Gb :GrepBuffer <args>
" カーソル下の単語をGrepBufferする
nnoremap <C-g><C-b> :<C-u>GrepBuffer<Space><C-r><C-w><Enter>

" :Gr <args>でカレントディレクトリ以下を再帰的にgrepする
command! -nargs=1 Gr :Rgrep <args> *<Enter><CR>
" カーソル下の単語をgrepする
nnoremap <silent> <C-g><C-r> :<C-u>Rgrep<Space><C-r><C-w> *<Enter><CR>
" }}}

" === gundo.vim {{{
nnoremap U :<C-u>GundoToggle<CR>
" 移動と同時にプレビューを表示しない
" r を押すとプレビュー表示
" 履歴表示が遅い場合に設定すると良い
"let g:gundo_auto_preview = 0
" }}}

" === hier {{{
let g:hier_highlight_group_qf  = 'qf_error_ucurl'
let g:hier_highlight_group_qfw = 'qf_warning_ucurl'

" ハイライト箇所を更新
nnoremap <silent> <Leader>hiu :HierUpdate<CR>
" ハイライトを削除
nnoremap <silent> <Leader>hic :HierClear<CR>
" }}}

" === HybridText {{{
autocmd MyAutoCmd BufEnter,BufNewFile * if bufname('%') != '' && &filetype == ''
        \ | setlocal ft=hybrid | endif
" }}}

" === indent-guides {{{
" インデントガイドをトグルするキーバインド
nnoremap <silent> <Space>id :<C-u>IndentGuidesToggle<Enter>
" vim起動時の自動実行
let g:indent_guides_enable_on_vim_startup = 1
" 自動色付け
let g:indent_guides_auto_colors = 0
" インデントガイドの表示を開始するインデントレベル
let g:indent_guides_start_level = 2
" インデントガイドのサイズ(幅)
let g:indent_guides_guide_size = 1
" グラデーション設定(gvim only)
let g:indent_guides_color_change_percent = 30
" }}}

" === jasegment.vim {{{
nmap <silent> H <Plug>JaSegmentMoveNB
omap <silent> H <Plug>JaSegmentMoveOB
xmap <silent> H <Plug>JaSegmentMoveVB

" nmap <silent> L <Plug>JaSegmentMoveNW
" omap <silent> L <Plug>JaSegmentMoveOW
" xmap <silent> L <Plug>JaSegmentMoveVW

nmap <silent> L <Plug>JaSegmentMoveNE
omap <silent> L <Plug>JaSegmentMoveOE
xmap <silent> L <Plug>JaSegmentMoveVE
" }}}

" === jscomplete-vim {{{
" DOMとMozilla関連とES6のメソッドを補完
let g:jscomplete_use = ['dom', 'moz', 'es6th']
" }}}

" === jQuery {{{
au BufRead,BufNewFile jquery.*.js setl ft=javascript syntax=jquery
" }}}

" === less-autocompile {{{
"自動で変換
let g:less_autocompile=1
"圧縮しない
let g:less_compress=0
" }}}

" === matchit.vim {{{
"  %コマンドによる対応括弧ジャンプ機能の拡張
"--------------------------------------------
runtime macros/matchit.vim
let b:match_ignorecase = 1
" 対応する括弧を追加
"let b:match_words = "if:endif,foreach:endforeach,\<begin\>:\<end\>"
" }}}

" === MiniBufExplorer {{{
" set minibfexp
let g:miniBufExplMapWindowNavVim=1 "hjklで移動
let g:miniBufExplSplitBelow=0  " Put new window above
let g:miniBufExplMapWindowNavArrows=1
let g:miniBufExplMapCTabSwitchBufs=1
let g:miniBufExplModSelTarget=1
let g:miniBufExplSplitToEdge=1
let g:miniBufExplMaxSize = 10

" :MtでMiniBufExplorerの表示トグル
command! Mt :TMiniBufExplorer
" }}}

" === neocomplcache {{{
augroup InitNecoSeriesAu
  autocmd!
  autocmd InsertEnter * call <SID>init_neco_series()
augroup END
function! s:init_neco_series()
  NeoBundleSource neocomplcache
  NeoBundleSource neosnippet
  augroup InitNecoSeriesAu
    autocmd!
  augroup END
endfunction

" 補完にneocomplcacheを使う
source ~/dotfiles/.vimrc.neocomplcache
" }}}

" === nerd_commenter.vim {{{
" <Leader>c<Space> : コメントトグル
"------------------------------------------------
" コメントの間にスペースを空ける
let nerdspacedelims=1
" 未対応ファイルタイプのエラーメッセージを表示しない
let nerdshutup=1
" }}}

" === nerdtree {{{
"  http://blog.livedoor.jp/kumonopanya/archives/51048805.html

"  Commands
"    NERDTreeFromBookmark
"    NERDTreeFind
"    NERDTreeCWD
"
"  Mappings
"    o/Enter : Open the item and the cursor move in the window.
"    O : Recursively open the selected directory.
"    go : Open the item but the cursor dose not move.
"    t : Open in a new tab.
"    T : The same as t except that the focus is kept in the current tab.
"    i : Opne in a new horizonatal split window.
"    I : The same as i except that the cursor is not moved.
"    s : Opne in a new vertical split window.
"    S : The same as i except that the cursor is not moved.
"    x : Closes the parent of the selected node.
"    X : Recursively closes all children of the selected directory.
"    p : Jump to the parent node of the selected node.
"    K : Jump to the first child of the current nodes parent.
"    J : Jump to the last child of the current nodes parent.
"    u : Move the tree root up a dir (like doing a "cd ..").
"    r.R : Refresh.
"    m : Menu.
"    cd : Change vims current working directory to that of the selected node.
"    CD : Change tree root to vims current working directory.
"    ? : Quick help.
"-------------------------------------------------------------
let bundle = neobundle#get('nerdtree')
function! bundle.hooks.on_source(bundle)
  " ツリー表示幅
  "let g:NERDTreeWinSize=31

  " 無視するファイルを設定 (正規表現)
  let g:NERDTreeIgnore = [
        \ '\.clean$', '\.swp$', '\.bak$', '\~$',
        \ '\.svn$', '\.git$',
        \ ]

  " 隠しファイル表示ON
  let g:NERDTreeShowHidden=1
  " ツリー上部のヘルプ表示OFF
  let g:NERDTreeMinimalUI=1
  " ツリーに矢印などを表示OFF
  let g:NERDTreeDirArrows=0

  "マウス操作方法
  " 1 : ファイル、ディレクトリ両方共ダブルクリックで開く(default)
  " 2 : ディレクトリのみシングルクリックで開く
  " 3 : ファイル、ディレクトリ両方共シングルクリックで開く
  let g:NERDTreeMouseMode=1
endfunction
unlet bundle

" トグル
" nmap <silent> <F5> :call <SID>toggle_nerdtree()<cr>
" function! s:toggle_nerdtree()
"   NERDTreeToggle
"   if &buftype ==# 'nofile' && bufname('') ==# '-MiniBufExplorer-'
"     execute 'wincmd w'
"   endif
" endfunction

" 自動実行
" if has('vim_starting') && len(expand('%:p')) == 0
"     autocmd MyAutoCmd VimEnter * if !argc() | NERDTreeToggle | execute 'wincmd w'
" endif
" }}}

" === netrw.vim {{{
let g:netrw_list_hide= '*.swp'
"nnoremap <silent> <BS> :<C-u>Explore<CR>
" Change default directory.
if has('browse')
  set browsedir=current
endif
" }}}

" === niceblock {{{
" Improved visual selection.
xmap I  <Plug>(niceblock-I)
xmap A  <Plug>(niceblock-A)
" }}}

" === nodejs-complete {{{
"  Close the method preview window.
"    ctrl-w_ctrl-z or :pc
"  Clear the chache for node modules.
"   :unlet b:npm_module_names
" ------------------------------------
let g:nodejs_complete_config = {
      \ 'js_compl_fn': 'javascriptcomplete#CompleteJS',
      \ 'max_node_compl_len': 15,
      \ }
" automatically open and close the popup menu / preview window
"au CursorMovedI,InsertLeave * if pumvisible() == 0|silent! pclose|endif
" }}}

" === number-marks {{{
let g:number_marks_no_default_key_mappings = 1
nmap <silent> mm <Plug>number-marks-place-sign
nmap <silent> mb <Plug>number-marks-goto-next-sign
nmap <silent> mv <Plug>number-marks-goto-prev-sign
nmap <silent> mD <Plug>number-marks-remove-all-signs
nmap <silent> m. <Plug>number-marks-move-sign

"nmap <silent> <unique> <F5> <Plug>number-marks-savep
"nmap <silent> <unique> <F6> <Plug>number-marks-reloadp
" }}}

" === open-browser.vim {{{
" カーソル下のURLをブラウザで開く
" URLがない場合は単語を検索する
nmap <Leader>ob <Plug>(openbrowser-smart-search)
vmap <Leader>ob <Plug>(openbrowser-smart-search)

" カーソル下のURLをブラウザで開く
" nmap <Leader>fu <Plug>(openbrowser-open)
" vmap <Leader>fu <Plug>(openbrowser-open)
" カーソル下のキーワードをググる
"nnoremap <Leader>fs :<C-u>OpenBrowserSearch<Space><C-r><C-w><Enter>

" 入力した単語をブラウザで検索
nmap <Leader>gs <Plug>(open-browser-wwwsearch)

let bundle = neobundle#get('open-browser.vim')
function! bundle.hooks.on_source(bundle)
  nnoremap <Plug>(open-browser-wwwsearch)
        \ :<C-u>call <SID>www_search()<CR>
  function! s:www_search()
    let search_word = input('Please input search word: ', '',
          \ 'customlist,wwwsearch#cmd_Wwwsearch_complete')
    if search_word != ''
      execute 'OpenBrowserSearch' escape(search_word, '"')
    endif
  endfunction
endfunction
unlet bundle
" }}}

" === operator-replace {{{
nmap R <Plug>(operator-replace)
xmap R <Plug>(operator-replace)
xmap p <Plug>(operator-replace)
nmap cp <Plug>(operator-replace)iw
nmap vp <Plug>(operator-replace)iw
" }}}

" === operator-html-escape {{{
nmap <Leader>h <Plug>(operator-html-escape)
xmap <Leader>h <Plug>(operator-html-escape)
" }}}

" === powerline {{{
if has('multi_byte')
  " パッチ当てフォントを使用
  let g:Powerline_symbols = 'fancy'
endif

"let g:Powerline_stl_path_style = 'full'

"let g:Powerline_theme = 'solarized256'
"let g:Powerline_colorscheme = 'solarized256'

call Pl#Theme#InsertSegment('charcode', 'before', 'fileformat')

" http://d.hatena.ne.jp/itchyny/20120609/1339249777
let g:Powerline_mode_n = 'NORMAL'
call Pl#Hi#Allocate({
  \ 'black'          : 16,
  \ 'white'          : 231,
  \
  \ 'darkestgreen'   : 22,
  \ 'darkgreen'      : 28,
  \
  \ 'darkestcyan'    : 21,
  \ 'mediumcyan'     : 117,
  \
  \ 'darkestblue'    : 24,
  \ 'darkblue'       : 31,
  \
  \ 'darkestred'     : 52,
  \ 'darkred'        : 88,
  \ 'mediumred'      : 124,
  \ 'brightred'      : 160,
  \ 'brightestred'   : 196,
  \
  \ 'darkestyellow'  : 59,
  \ 'darkyellow'     : 100,
  \ 'darkestpurple'  : 57,
  \ 'mediumpurple'   : 98,
  \ 'brightpurple'   : 189,
  \
  \ 'brightorange'   : 208,
  \ 'brightestorange': 214,
  \
  \ 'gray0'          : 233,
  \ 'gray1'          : 235,
  \ 'gray2'          : 236,
  \ 'gray3'          : 239,
  \ 'gray4'          : 240,
  \ 'gray5'          : 241,
  \ 'gray6'          : 244,
  \ 'gray7'          : 245,
  \ 'gray8'          : 247,
  \ 'gray9'          : 250,
  \ 'gray10'         : 252,
  \ })
" 'n': normal mode
" 'i': insert mode
" 'v': visual mode
" 'r': replace mode
" 'N': not active
let g:Powerline#Colorschemes#my#colorscheme = Pl#Colorscheme#Init([
  \ Pl#Hi#Segments(['SPLIT'], {
    \ 'n': ['white', 'gray2'],
    \ 'N': ['gray1', 'gray1'],
    \ }),
  \
  \ Pl#Hi#Segments(['mode_indicator'], {
    \ 'i': ['darkestgreen', 'white', ['bold']],
    \ 'n': ['darkestcyan', 'white', ['bold']],
    \ 'v': ['darkestpurple', 'white', ['bold']],
    \ 'r': ['mediumred', 'white', ['bold']],
    \ 's': ['white', 'gray5', ['bold']],
    \ }),
  \
  \ Pl#Hi#Segments(['fileinfo', 'filename'], {
    \ 'i': ['white', 'darkestgreen', ['bold']],
    \ 'n': ['white', 'darkestcyan', ['bold']],
    \ 'v': ['white', 'darkestpurple', ['bold']],
    \ 'r': ['white', 'mediumred', ['bold']],
    \ 'N': ['gray0', 'gray2', ['bold']],
    \ }),
  \
  \ Pl#Hi#Segments(['branch', 'scrollpercent', 'raw', 'filesize'], {
    \ 'n': ['gray2', 'gray7'],
    \ 'N': ['gray0', 'gray2'],
    \ }),
  \
  \ Pl#Hi#Segments(['fileinfo.filepath', 'status'], {
    \ 'n': ['gray10'],
    \ 'N': ['gray5'],
    \ }),
  \
  \ Pl#Hi#Segments(['static_str'], {
    \ 'n': ['white', 'gray4'],
    \ 'N': ['gray1', 'gray1'],
    \ }),
  \
  \ Pl#Hi#Segments(['fileinfo.flags'], {
    \ 'n': ['white'],
    \ 'N': ['gray4'],
    \ }),
  \
  \ Pl#Hi#Segments(['currenttag', 'fileformat', 'fileencoding', 'pwd',
  \'filetype', 'charcode', 'currhigroup'], {
    \ 'n': ['gray9', 'gray4'],
    \ }),
  \
  \ Pl#Hi#Segments(['lineinfo'], {
    \ 'n': ['gray2', 'gray10'],
    \ 'N': ['gray2', 'gray4'],
    \ }),
  \
  \ Pl#Hi#Segments(['errors'], {
    \ 'n': ['white', 'gray2'],
    \ }),
  \
  \ Pl#Hi#Segments(['lineinfo.line.tot'], {
    \ 'n': ['gray2'],
    \ 'N': ['gray2'],
    \ }),
  \
  \ Pl#Hi#Segments(['paste_indicator', 'ws_marker'], {
    \ 'n': ['white', 'brightred', ['bold']],
    \ }),
  \
  \ Pl#Hi#Segments(['gundo:static_str.name'], {
    \ 'n': ['white', 'mediumred', ['bold']],
    \ 'N': ['brightred', 'darkestred', ['bold']],
    \ }),
  \
  \ Pl#Hi#Segments(['gundo:static_str.buffer'], {
    \ 'n': ['white', 'darkred'],
    \ 'N': ['brightred', 'darkestred'],
    \ }),
  \
  \ Pl#Hi#Segments(['gundo:SPLIT'], {
    \ 'n': ['white', 'gray2'],
    \ 'N': ['white', 'gray0'],
    \ }),
  \ ])
let g:Powerline_colorscheme = 'my'
" }}}

" === python {{{

" python.vim
let python_highlight_all = 1

"------------------------------------
" Pydiction
"  辞書補完
"------------------------------------
"let g:pydiction_location = '~/.vim/pydiction/complete-dict'
"let g:pydiction_location = '~/.vim/bundle/Pydiction/complete-dict'

"------------------------------------
" pythoncomplete
"  オムニ補完
"------------------------------------
"setlocal omnifunc=pythoncomplete#Complete
" オムに補完はpython-mode(RopeOmni)を使用

"------------------------------------
" python-mode
"  https://github.com/klen/python-mode
"  :help PythonModeOptions
"  :help PythonModeKeys
"  :help ropevim.txt
"------------------------------------
let bundle = neobundle#get('python-mode')
function! bundle.hooks.on_source(bundle)
  " ## Run python
  " Load run code plugin
  let g:pymode_run = 0
  " Key for run python code
  let g:pymode_run_key = '<Leader>r'

  " ## Show documentation
  " Load show documentation plugin
  let g:pymode_doc = 0
  " Key for show python documentation
  let g:pymode_doc_key = 'K'

  " ## Lint
  " Load pylint code plugin
  let g:pymode_lint = 0
  " Disable pylint checking every save
  let g:pymode_lint_write = 1
  " Switch pylint, pyflakes, pep8, mccabe code-checkers
  let g:pymode_lint_checker = "pep8,pyflakes,mccabe"
  " on django
  "let g:pymode_lint_cheker = "pylint"

  " ## Window
  " Hold cursor in current window
  " when quickfix is open
  let g:pymode_lint_hold = 0
  " Minimal height of pylint error window
  let g:pymode_lint_minheight = 3
  " Maximal height of pylint error window
  let g:pymode_lint_maxheight = 6

  " ## Foldin
  " Enable python folding
  let g:pymode_folding = 1

  " ## Rope
  " Load rope plugin
  let g:pymode_rope = 0
  " Auto create and open ropeproject
  let g:pymode_rope_auto_project = 0

  " ## etc
  " Auto fix vim python paths if virtualenv enabled
  let g:pymode_virtualenv = 1
endfunction
unlet bundle

"------------------------------------
" jedi-vim
"  https://github.com/davidhalter/jedi-vim
"------------------------------------
let bundle = neobundle#get('jedi-vim')
function! bundle.hooks.on_source(bundle)
  let g:jedi#auto_initialization = 1
  let g:jedi#goto_command = "<leader>gt"
  let g:jedi#get_definition_command = "<leader>d"
  let g:jedi#pydoc = "<space>K"
  let g:jedi#rename_command = "<leader>R"
  let g:jedi#related_names_command = "<leader>n"
  let g:jedi#popup_on_dot = 0
endfunction
unlet bundle

augroup InitJediVimAu
  autocmd!
  autocmd InsertEnter *.py call <SID>init_jedi()
augroup END
function! s:init_jedi()
  NeoBundleSource jedi-vim
  augroup InitJediVimAu
    autocmd!
  augroup END
endfunction
" }}}

" === qfreplace.vim {{{
autocmd MyAutoCmd FileType qf nnoremap <buffer> r :<C-u>Qfreplace<CR>
" }}}

" === quickrun {{{
let bundle = neobundle#get('vim-quickrun')
function! bundle.hooks.on_source(bundle)
  " デフォルトのキーマップを無効
  let g:quickrun_no_default_key_mappings = 1
  " コンフィグ設定
  " 常に横分割
  " markdownについて
  "  htmlを開くデフォルトアプリケーションがブラウザの場合は
  "   'outputter': 'multi:buffer:browser'
  "  とすることでブラウザにて開くことができる
  let g:quickrun_config = {
        \   '_': {
        \     'split': '',
        \     'runner' : 'vimproc',
        \     'runner/vimproc/updatetime' : 60,
        \     'outputter/buffer/close_on_empty' : 1,
        \   },
        \   'markdown': {
        \     'type': executable('markdown') ? 'markdown/markdown':
        \             executable('Markdown.pl') ? 'markdown/Markdown.pl':
        \             executable('kramdown') ? 'markdown/kramdown':
        \             executable('bluecloth') ? 'markdown/bluecloth':
        \             executable('redcarpet') ? 'markdown/redcarpet':
        \             executable('pandoc') ? 'markdown/pandoc':
        \             executable('markdown_py') ? 'markdown/markdown_py': '',
        \   },
        \   'markdown/markdown': {
        \     'split': winwidth(0) < winheight(0) * 3  ? "" : "vertical",
        \     'command': 'markdown',
        \     'cmdopt': '--html4tags',
        \     'args': '| tee /tmp/__markdown_for_quickrun.html; open -a Google\ Chrome /tmp/__markdown_for_quickrun.html',
        \     'outputter': 'multi:buffer',
        \   },
        \ }
endfunction
unlet bundle

" 通常実行
nmap <silent> <Leader>r <Plug>(quickrun)
" 実行後フォーカスをQuickFixへ
nmap <silent> <Leader>R <Plug>(quickrun)<C-w><C-w>
" 引数付き実行
command! -nargs=+ QR :QuickRun '-args' <q-args>
" Quickrunの強制停止
nnoremap <expr><silent> <C-c> quickrun#is_running() ?  quickrun#sweep_sessions() : '<C-c>'
" }}}

" === quickfixsigns_vim {{{
let g:quickfixsigns_classes = ['qfl', 'loc', 'breakpoints']
" }}}

" === ref {{{
let g:ref_no_default_key_mappings = 1
silent! nmap <silent> <unique> <Leader>k <Plug>(ref-keyword)
silent! vmap <silent> <unique> <Leader>k <Plug>(ref-keyword)
let bundle = neobundle#get('vim-ref')
function! bundle.hooks.on_source(bundle)
  let g:ref_use_vimproc = 1
  let is_windows = has('win16') || has('win32') || has('win64')
  if is_windows
    let g:ref_refe_encoding = 'cp932'
  else
    let g:ref_refe_encoding = 'euc-jp'
  endif

  " ref-lynx.
  if is_windows
    let lynx = 'C:/lynx/lynx.exe'
    let cfg  = 'C:/lynx/lynx.cfg'
    let g:ref_lynx_cmd = s:lynx.' -cfg='.s:cfg.' -dump -nonumbers %s'
    let g:ref_alc_cmd = s:lynx.' -cfg='.s:cfg.' -dump %s'
  endif
  let g:ref_lynx_use_cache = 1
  let g:ref_lynx_start_linenumber = 0 " Skip.
  let g:ref_lynx_hide_url_number = 0

  autocmd MyAutoCmd FileType ref call s:ref_my_settings()
  function! s:ref_my_settings()
    " Overwrite settings.
    nmap <buffer> [Tag]t  <Plug>(ref-keyword)
    nmap <buffer> [Tag]p  <Plug>(ref-back)
    nmap <buffer> b <Plug>(ref-back)
    nmap <buffer> f <Plug>(ref-forward)
    "setlocal nonumber
  endfunction

  " PHPマニュアルのパスを指定
  let g:ref_phpmanual_path = $HOME . '/work/dev/docs/php-chunked-xhtml'

  " Javadocのパスを指定
  let g:ref_javadoc_path = $HOME . '/work/dev/docs/java6_ja_apidocs'

  " jqueryリファレンスのパスを指定
  let g:ref_jquery_doc_path = $HOME . '/work/dev/docs/jqapi-latest'

  " javascriptリファレンスのパスを指定
  let g:ref_javascript_doc_path = $HOME . '/work/dev/docs/jsref/htdocs'

  " ref-sourcesにてキャッシュを有効
  let g:ref_use_cache = 1

endfunction
unlet bundle
"}}}

" === restart.vim {{{
if has('gui_running')
  command! RestartWithSession
        \ -bar
        \ let g:restart_sessionoptions = 'blank,buffers,curdir,folds,help,localoptions,tabpages'
        \ | Restart
endif
" }}}

" === seek {{{
"let g:seek_enable_jumps = 1
"nmap <silent> s <Plug>(seek-seek)
"omap <silent> s <Plug>(seek-seek)
"nmap <silent> S <Plug>(seek-back)
"omap <silent> S <Plug>(seek-back)
"omap <silent> x <Plug>(seek-seek-cut)
"omap <silent> X <Plug>(seek-back-cut)
"omap <silent> j <Plug>(seek-jump)
"omap <silent> J <Plug>(seek-jump-back)
" }}}

" === showmarks.vim {{{
"  <Leader>mt ON/OFFトグル
"  <Leader>mo Forces ShowMarks on.
"  <Leader>mm 次の使えるマークを使ってマーク
"  <Leader>mh カレント行ののマークを削除
"  <Leader>ma カレントバッファのマークを全部削除
"----------------------------------------------------
" Enable ShowMarks
let showmarks_enable = 1
" Show which marks
let showmarks_include = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"

" マークを表示しない
"   - h : Help
"   - m : Non-modifiable
"   - p : Preview
"   - q : Quickfix
"   - r : Readonly
let showmarks_ignore_type = "hmq"

" Hilight lower & upper marks
"let showmarks_hlline_lower = 1
"let showmarks_hlline_upper = 1
" }}}

" === Simple-Javascript-Indenter {{{
" shiftwidthを1にしてインデント
let g:SimpleJsIndenter_BriefMode = 1
" switchのインデント改善
let g:SimpleJsIndenter_CaseIndentLevel = -1
" }}}

" === sumartword {{{
"nmap W   <Plug>(smartword-w)
"nmap B   <Plug>(smartword-b)
"nmap E   <Plug>(smartword-e)
"nmap ge  <Plug>(smartword-ge)

"nmap w  <Plug>(smartword-w)
"nmap b  <Plug>(smartword-b)
"nmap ge  <Plug>(smartword-ge)
"xmap w  <Plug>(smartword-w)
"xmap b  <Plug>(smartword-b)

" Operator pending mode.
"omap <Leader>w  <Plug>(smartword-w)
"omap <Leader>b  <Plug>(smartword-b)
"omap <Leader>ge  <Plug>(smartword-ge)
" }}}

" === submode {{{
let bundle = neobundle#get('vim-submode')
function! bundle.hooks.on_source(bundle)
  " タイムアウト無効
  let g:submode_timeout = 0

  " タイムアウト時間 (ms)
  " let g:submode_timeoutlen = 10000

  " サブモードに入るためのキーマッピング定義
  "  submode#enter_with({submode}, {modes}, {options}, {lhs}, [{rhs}])
  "   {submode} : サブモード名
  "   {modes} : モートの種類 (複数指定可) (n = normal-mode、i = insert-mode ...)
  "   {options} : オプション (b = <buffer> e = <expr> ...)
  "   {lhs}
  "   [{rhs}]
  "
  " サブモード中のキーマッピング
  " submode#map({submode}, {modes}, {options}, {lhs}, {rhs})
  "
  " サブモードから抜ける : ESC

  call submode#enter_with('winsize', 'n', '', '<C-w><Space>')

  call submode#map('winsize', 'n', '', 'l', '<C-w>>')
  call submode#map('winsize', 'n', '', 'h', '<C-w><')
  call submode#map('winsize', 'n', '', 'k', '<C-w>-')
  call submode#map('winsize', 'n', '', 'j', '<C-w>+')
endfunction
unlet bundle
nnoremap <Space><Space> :NeoBundleSource vim-submode<cr>
"}}}

" === sudo.vim {{{
" root権限で今開いているファイルを開き直す
command! ES :e sudo:%<CR><C-^>:bd!
" root権限で保存
command! WS :w sudo:%
" }}}

" === surround.vim {{{
let g:surround_no_mappings = 1

"let g:surround_{char2nr('e')} = 'begin \r end'
"let g:surround_{char2nr('d')} = 'do \r end'
"let g:surround_{char2nr("-")} = ':\r'

nmap ds  <Plug>Dsurround
nmap cs  <Plug>Csurround
nmap ys  <Plug>Ysurround
nmap yS  <Plug>YSurround
nmap yss <Plug>Yssurround
nmap ySs <Plug>YSsurround
"nmap S <Plug>Ysurround
"nmap SS <Plug>Yssurround
nmap ySS <Plug>YSsurround
xmap S   <Plug>VSurround
xmap gS  <Plug>VgSurround

if !hasmapto("<Plug>Isurround","i") && "" == mapcheck("<C-S>","i")
  imap    <C-S> <Plug>Isurround
endif
imap      <C-G>s <Plug>Isurround
imap      <C-G>S <Plug>ISurround
" }}}

" === Syntastic {{{
"  Syntastic が使用するコマンド
"   http://d.hatena.ne.jp/heavenshell/20120109/1326089510
"  実行：,s
"  自動実行のトグル：,S
"  エラー一覧(QiuickFix)表示：,e
"------------------------------------
let bundle = neobundle#get('syntastic')
function! bundle.hooks.on_source(bundle)
  " エラー行をsignで表示
  let g:syntastic_enable_signs = 1
  " エラーバルーン表示 (gvim only)
  let g:syntastic_enable_balloons =1
  " エラーhighligt表示
  let g:syntastic_enable_highlighting = 1
  " エラー時にquickfix起動
  let g:syntastic_auto_loc_list = 1

  " Automatically running
  "   mode(active/passive)
  let g:syntastic_mode_map = { 'mode': 'active',
        \ 'active_filetypes': ['ruby', 'php', 'perl'],
        \ 'passive_filetypes': ['python', 'html', 'coffee', 'javascript'] }

  " python
  let g:syntastic_python_checkers = [ "flake8", "pyflakes" ]
  " javascript
  let g:syntastic_javascript_checkers = [ "gjslint", "jshint" ]
  " coffee
  let g:syntastic_coffee_checkers = [ "coffeelint", "coffee" ]
endfunction
unlet bundle

" シンタックスチェックを実行
nnoremap <silent> <Leader>s :SyntasticCheck<CR>
" シンタックスチェックのモードをトグル(active/passive)
nnoremap <silent> <Leader>S :SyntasticToggleMode<CR>
" QuickFixによるエラー一覧表示
nnoremap <silent> <Leader>e :Errors<CR>
" }}}

" === switch.vim {{{
let bundle = neobundle#get('switch.vim')
function! bundle.hooks.on_source(bundle)
  " CamelCase <-> SneakCase
  let g:variable_style_switch_definitions = [
    \   {
    \     '\<[a-z0-9]\+_\k\+\>': {
    \       '_\(.\)': '\U\1'
    \     },
    \     '\<[a-z0-9]\+[A-Z]\k\+\>': {
    \       '\([A-Z]\)': '_\l\1'
    \     },
    \   }
    \ ]

  let g:switch_custom_definitions =
    \ [
    \   ['and', 'or'],
    \   ['if', 'unless'],
    \   ['yes', 'no'],
    \   ['enable', 'disable'],
    \   ['pick', 'reword', 'fixup', 'squash', 'edit', 'exec'],
    \ ]
endfunction
unlet bundle

nnoremap <silent> + :call switch#Switch(g:variable_style_switch_definitions)<cr>
nnoremap <silent> - :Switch<cr>
" }}}

" === tcomment_vim {{{
" let g:tcommentModeExtra = '>>'
" Set explicitly default mappings for neobundle.
nnoremap <silent> <C-_><C-_> :TComment<cr>
vnoremap <silent> <C-_><C-_> :TCommentMaybeInline<cr>
inoremap <silent> <C-_><C-_> :TComment<cr>

" Compatible mappings for nerdcommenter.
nnoremap <silent> <Leader>c<Space> :TComment<cr>
vnoremap <silent> <Leader>c<Space> :TCommentMaybeInline<cr>
inoremap <silent> <Leader>c<Space> :TComment<cr>
" }}}

" === tern_for_vim {{{
" Commands.
"   :TernDef        Jump to the definition of the thing under the cursor.
"   :TernDefPreview Look up definition in preview
"   :TernDefSplit   Look up definition in new split
"   :TernDefTab     Look up definition in new tab
"   :TernDoc        Look up the documentation of something.
"   :TernDocBrowse  Browse the Documentation.
"   :TernType       Find the type of the thing under the cursor.
"   :TernRefs       Show all references to the variable or property under the cursor.
"   :TernRename     Rename the variable under the cursor.

let bundle = neobundle#get('tern_for_vim')
function! bundle.hooks.on_source(bundle)
  " Show argumet hints. (no/on_move/on_hold) (Default: no)
  let g:tern_show_argument_hints = 'on_hold'

  " Set default key mappings.
  " let g:tern_map_keys = 1
  " Set prefix key.
  " let g:tern_map_prefix = '<leader>'

  " Key mapping list.
  "   prefix + td   :TernDoc<CR>'
  "   prefix + tb   :TernDocBrowse<CR>'
  "   prefix + tt   :TernType<CR>'
  "   prefix + td   :TernDef<CR>'
  "   prefix + tpd  :TernDefPreview<CR>'
  "   prefix + tsd  :TernDefSplit<CR>'
  "   prefix + ttd  :TernDefTab<CR>'
  "   prefix + tr   :TernRefs<CR>'
  "   prefix + tR   :TernRename<CR>'

  " Run ftplugin process.
  " NeoBundleLazyだと after/ftplugin/javascript_tern.vim が読み込まれない
  call tern#Enable()
  " Menu
  menu <silent> Tern.Jump\ To\ Defintion :TernDef<CR>
  menu <silent> Tern.See\ Documentation :TernDoc<CR>
  menu <silent> Tern.DataType :TernType <CR>
  menu <silent> Tern.Show\ all\ References :TernRefs<CR>
  menu <silent> Tern.Rename :TernRename <CR>
endfunction
unlet bundle
" }}}

" === tabpagecd {{{
autocmd MyAutoCmd TabEnter * NeoBundleSource vim-tabpagecd
" }}}

" === TweetVim {{{
let bundle = neobundle#get('TweetVim')
function! bundle.hooks.on_source(bundle)
  if has('gui_running')
    " フレームにアイコンを表示
    let g:tweetvim_display_icon = 1
  endif

  " 1ページのツイート数
  let g:tweetvim_tweet_per_page = 60

  " セパレータOFF
  let g:tweetvim_display_separator = 0

  autocmd MyAutoCmd FileType tweetvim call s:tweetvim_my_settings()
  function! s:tweetvim_my_settings()
    nnoremap <silent><buffer> o :TweetVimSay<CR>
    nnoremap <silent><buffer> q :close<CR>
    nmap <silent><buffer> j <Plug>(accelerated_jk_gj)
  endfunction
endfunction
unlet bundle

nnoremap <silent><Space>tw :<C-u>tabnew <Bar> TweetVimHomeTimeline<CR>
nnoremap <silent><Space>tl :<C-u>TweetVimHomeTimeline<CR>
nnoremap <silent><Space>tm :<C-u>TweetVimMentions<CR>
"nnoremap <Space>ts :<C-u>TweetVimSay<CR>
" }}}

" === txtobj {{{
" vim-textobj-multiblock
omap ab <Plug>(textobj-multiblock-a)
omap ib <Plug>(textobj-multiblock-i)
vmap ab <Plug>(textobj-multiblock-a)
vmap ib <Plug>(textobj-multiblock-i)
" }}}

" === unite.vim {{{
" The prefix key.
nnoremap    [unite]   <Nop>
xnoremap    [unite]   <Nop>
nmap    ;f   [unite]
xmap    ;f   [unite]


nnoremap [unite]u  :<C-u>Unite<Space>

" 全部乗せ
nnoremap <silent> [unite]a  :<C-u>UniteWithCurrentDir -buffer-name=files buffer file_mru bookmark file<CR>
" 常用セット
nnoremap <silent> [unite]j  :<C-u>Unite buffer file_mru<CR>
" ファイル一覧
nnoremap <silent> [unite]f  :<C-u>Unite -buffer-name=files file<CR>
" ファイル一覧 (現在のバッファのカレントディレクトリ配下)
nnoremap <silent> [unite]d  :<C-u>UniteWithBufferDir file<CR>
" バッファ一覧
nnoremap <silent> [unite]b  :<C-u>Unite buffer<CR>
" 最近使用したファイル一覧
nnoremap <silent> [unite]m  :<C-u>Unite file_mru<CR>
" 最近使用したファイル一覧 (カレントディレクトリ)
"nnoremap <silent> [unite]m  :<C-u>UniteWithBufferDir file_mru<CR>
" ブックマーク
nnoremap <silent> [unite]b  :<C-u>Unite -buffer-name=bookmark bookmark<CR>

" dotfiles以下のファイルを表示
command! Ufd :Unite file:~/dotfiles -input=. -no-start-insert -winwidth=60

command! Uba :UniteBookmarkAdd<CR>

" ----- unite-plugins -----
" yank/history
xnoremap <silent> ;y
      \ d:<C-u>Unite -buffer-name=register register history/yank<CR>
nnoremap <silent> ;y
      \ :<C-u>Unite -buffer-name=register register history/yank<CR>

" unite-line
" uniteでバッファ内検索//
"  <C-u> 余計な文字が入っていた場合に行頭まで削除することで正常に動作させる
command! Ul :Unite -buffer-name=search -start-insert -no-quit -auto-preview line_migemo

" unite-grep
"  Targetに-Rを入れることで再帰検索可能
" キーマップ
command! Ug :Unite -no-start-insert -buffer-name=search -no-quit grep


" Unite buffer_tab -buffer-name=buflist -hide-source-names -hide-status-line -no-focus -resume -horizontal -auto-preview -auto-resize -toggle -no-quit -no-start-insert -winheight=10 -direction=leftbelow
" Sources :
"
" Unite build -buffer-name=build tabpagenr() -no-quit
" Unite change jump
" Unite grep -buffer-name=search -auto-preview -no-quit -resume
" Unite help
" Unite -buffer-name=help help
" Unite jump
" Unite history/command command
" Unite -buffer-name=register register history/yank
" Unite menu:unite -resume
" Unite outline -start-insert -resume
" Unite -buffer-name=register register history/yank
" Unite source
" Unite tab
" Unite window

" Unite -buffer-name=files -no-split -multi-line
        "\ jump_point file_point buffer_tab
        "\ file_rec:! file file/new file_mru
" Unite -buffer-name=files -no-split -multi-line
        "\ jump_point file_point buffer_tab
        "\ file_rec/async:! file file/new file_mru

" UniteWithCursorWord help
" UniteWithCursorWord -buffer-name=tag tag tag/include
" UniteWithCursorWord -buffer-name=registerbuffer
      "\ file_mru bookmark file

" UniteBookmarkAdd
" UniteResume search -no-start-insert

" Unite -buffer-name=search -no-split -auto-preview
      "\ -start-insert line:backward


" unit-help
command! Uh :Unite help
" カーソル上の単語をunite-helpで検索
command! Uhw :UniteWithCursorWord help

" unite-outline
"nnoremap <silent> ;o
      "\ :<C-u>Unite outline -start-insert -resume<CR>
command! Uo :Unite -no-start-insert -winwidth=40 -start-insert -resume -no-quit outline

" unite-colorscheme
command! Uc :Unite -auto-preview -no-start-insert -winwidth=15 colorscheme

" unite-mapping
command! Um :Unite -no-start-insert mapping

" unite-quickfix
command! Uq :Unite -no-quit -direction=botright quickfix
command! Uq :Unite -no-quit -direction=botright location_list

" tweetvim
command! Utw :Unite tweetvim

" Alias
let g:unite_source_alias_aliases = {}
let g:unite_source_alias_aliases.line_migemo = {
      \ 'source' : 'line',
      \ }

" unite-menu.
let g:unite_source_menu_menus = {}

let g:unite_source_menu_menus.enc = {
      \     'description' : 'Open with a specific character code again.',
      \ }
let g:unite_source_menu_menus.enc.command_candidates = [
      \       ['utf8', 'Utf8'],
      \       ['iso2022jp', 'Iso2022jp'],
      \       ['cp932', 'Cp932'],
      \       ['euc', 'Euc'],
      \       ['utf16', 'Utf16'],
      \       ['utf16-be', 'Utf16be'],
      \       ['jis', 'Jis'],
      \       ['sjis', 'Sjis'],
      \       ['unicode', 'Unicode'],
      \     ]
" nnoremap <silent> ;e :<C-u>Unite menu:enc<CR>

let g:unite_source_menu_menus.fenc = {
      \     'description' : 'Change file fenc option.',
      \ }
let g:unite_source_menu_menus.fenc.command_candidates = [
      \       ['utf8', 'WUtf8'],
      \       ['iso2022jp', 'WIso2022jp'],
      \       ['cp932', 'WCp932'],
      \       ['euc', 'WEuc'],
      \       ['utf16', 'WUtf16'],
      \       ['utf16-be', 'WUtf16be'],
      \       ['jis', 'WJis'],
      \       ['sjis', 'WSjis'],
      \       ['unicode', 'WUnicode'],
      \     ]
" nnoremap <silent> ;f :<C-u>Unite menu:fenc<CR>

let g:unite_source_menu_menus.ff = {
      \     'description' : 'Change file format option.',
      \ }
let g:unite_source_menu_menus.ff.command_candidates = {
      \       'unix'   : 'WUnix',
      \       'dos'    : 'WDos',
      \       'mac'    : 'WMac',
      \     }
" nnoremap <silent> ;w :<C-u>Unite menu:ff<CR>

let g:unite_source_menu_menus.unite = {
      \     'description' : 'Start unite sources',
      \ }
let g:unite_source_menu_menus.unite.command_candidates = {
      \       'bookmark'   : 'Unite bookmark',
      \       'history'    : 'Unite history/command',
      \       'quickfix'   : 'Unite qflist -no-quit',
      \       'resume'     : 'Unite -buffer-name=resume resume',
      \       'directory'  : 'Unite -buffer-name=files '.
      \             '-default-action=lcd directory_mru',
      \       'mapping'    : 'Unite mapping',
      \       'message'    : 'Unite output:message',
      \     }
" nnoremap <silent> ;u :<C-u>Unite menu:unite -resume<CR>

let bundle = neobundle#get('unite.vim')
function! bundle.hooks.on_source(bundle)
  autocmd MyAutoCmd FileType unite call s:unite_my_settings()

  let g:unite_enable_start_insert = 0
  "let g:unite_enable_short_source_names = 1
  let g:unite_enable_split_vertically = 1
  let g:unite_winwidth = 40
  let g:unite_winheight = 20
  let g:unite_source_history_yank_enable = 1
  let g:unite_cursor_line_highlight = 'TabLineSel'
  let g:unite_source_file_mru_filename_format = ':~:.'
  let g:unite_source_file_mru_limit = 300
  let g:unite_source_directory_mru_limit = 300
  "let g:unite_abbr_highlight = 'TabLine'
  "let g:unite_source_file_mru_time_format = ''
  "let g:unite_source_directory_mru_time_format = ''

  " grepデフォルトオプション
  "  -i 大文字小文字を区別しない
  "  -n 各行の先頭にファイルの行番号を表示します
  "  -H ファイル名を表示
  "  -E オプションは、拡張正規表現を使用する場合に指定
  "     fgrep 正規表現を使わない検索
  "     egrep 正規表現を使った検索 -E と同じ
  "  -R ディレクトリを再帰的にたどる
  "  -I バイナリ検索除外
  "  -w 単語マッチ
  "  --color=[WHEN]
  "     always: パイプ使用時に強制的にカラーコードをつける
  "     auto : 出力先に応じて判断 - パイプ時などはカラーコードをつけない
  "     never : カラーコードOFF
  let g:unite_source_grep_default_opts="-niE --color=never"

  " For ag
  if executable('ag')
    let g:unite_source_grep_command = 'ag'
    let g:unite_source_grep_default_opts = '-S --nocolor --nogroup'
    let g:unite_source_grep_recursive_opt = ''
    let g:unite_source_grep_max_candidates = 200
  endif

  function! s:unite_my_settings()
    " ESCキーを2回押すと終了する
    nmap <buffer> <ESC>      <Plug>(unite_exit)
    nmap <buffer> <ESC><ESC> <Plug>(unite_exit)
    " 入力モードを抜ける
    imap <buffer> jj      <Plug>(unite_insert_leave)
    " 入力モード時のプレビュー
    nnoremap <silent><buffer> <C-p> :<C-u>call unite#mappings#do_action('preview')<CR>
    " 単語単位からパス単位で削除するように変更
    imap <buffer> <C-w>     <Plug>(unite_delete_backward_path)

    " ファイルを開く(ウィンドウ横分割)
    nnoremap <silent> <buffer> <expr> <C-s> unite#do_action('split')
    inoremap <silent> <buffer> <expr> <C-s> unite#do_action('split')

    " ファイルを開く(ウィンドウ縦分割)
    nnoremap <silent> <buffer> <expr> <C-v> unite#do_action('vsplit')
    inoremap <silent> <buffer> <expr> <C-v> unite#do_action('vsplit')

    " vimfiler
    nnoremap <silent> <buffer> <expr> <C-f> unite#do_action('vimfiler')
    inoremap <silent> <buffer> <expr> <C-f> unite#do_action('vimfiler')

    " Overwrite settings.
    " imap <buffer>  <BS>      <Plug>(unite_delete_backward_path)
    imap <buffer><expr> j unite#smart_map('j', '')
    imap <buffer> <TAB>   <Plug>(unite_select_next_line)
    imap <buffer> <C-w>     <Plug>(unite_delete_backward_path)
    imap <buffer> '     <Plug>(unite_quick_match_default_action)
    nmap <buffer> '     <Plug>(unite_quick_match_default_action)
    imap <buffer><expr> x
          \ unite#smart_map('x', "\<Plug>(unite_quick_match_choose_action)")
    nmap <buffer> x     <Plug>(unite_quick_match_choose_action)
    nmap <buffer> cd     <Plug>(unite_quick_match_default_action)
    nmap <buffer> <C-z>     <Plug>(unite_toggle_transpose_window)
    imap <buffer> <C-z>     <Plug>(unite_toggle_transpose_window)
    imap <buffer> <C-y>     <Plug>(unite_narrowing_path)
    nmap <buffer> <C-y>     <Plug>(unite_narrowing_path)
    nmap <buffer> <C-j>     <Plug>(unite_toggle_auto_preview)
    " nmap <buffer> <C-r>     <Plug>(unite_narrowing_input_history)
    " imap <buffer> <C-r>     <Plug>(unite_narrowing_input_history)
    nmap <silent><buffer> <Tab>     :call <SID>NextWindow()<CR>
    nnoremap <silent><buffer><expr> l
          \ unite#smart_map('l', unite#do_action('default'))
    nmap <buffer> <C-e>     <Plug>(unite_narrowing_input_history)

    let unite = unite#get_current_unite()
    if unite.buffer_name =~# '^search'
      nnoremap <silent><buffer><expr> r     unite#do_action('replace')
    else
      nnoremap <silent><buffer><expr> r     unite#do_action('rename')
    endif

    nnoremap <silent><buffer><expr> cd     unite#do_action('lcd')
    nnoremap <buffer><expr> S      unite#mappings#set_current_filters(
          \ empty(unite#mappings#get_current_filters()) ? ['sorter_reverse'] : [])

    let my_tabopen = {
          \ 'description' : 'my tabopen items',
          \ 'is_selectable' : 1,
          \ }
    function! my_tabopen.func(candidates)
      call unite#take_action('tabopen', a:candidates)

      let dir = isdirectory(a:candidates[0].word) ?
            \ a:candidates[0].word : fnamemodify(a:candidates[0].word, ':p:h')
      execute g:unite_kind_openable_lcd_command '`=dir`'
    endfunction
    call unite#custom_action('file,buffer', 'tabopen', my_tabopen)
    unlet my_tabopen

    " call unite#custom_source('file,buffer,file_rec', 'matchers', 'matcher_fuzzy')
    call unite#filters#sorter_default#use(['sorter_rank'])
    " call unite#custom_filters('file_rec', ['converter_relative_word', 'matcher_default', 'sorter_default', 'converter_relative_abbr'])

    " call unite#set_profile('action', 'context', {'start_insert' : 1})

    " Set "-no-quit" automatically in grep unite source.
    call unite#set_profile('source/grep', 'context', {'no_quit' : 1})

    " migemo.
    call unite#custom_source('line_migemo', 'matchers', 'matcher_migemo')
  endfunction
endfunction
unlet bundle

" }}}

" === versions {{{
" ログを見る際に、トピックブランチのコミットのみを列挙する
let g:versions#type#git#log#first_parent = 1

" UniteVersions {command}:{path}
"  {command}
"    branch
"    status
"    log
"    changeset
"  {path}
"    % カレントバッファ
"    ! カレントバッファのgitルートディレクトリ
nnoremap <silent> <Space>gS :<C-u>UniteVersions status:!<CR>
" }}}

" === vimfiler {{{
"
" Mappngs :
"   a   Action
"   e   Edit
"   v   preview
"   D   Split vertically edit
"   gc  Change current directory
"   yy  Copy file path
"   gr  Execute grep command
"   gf  Execute find command
"   x   Open with app
"   ge  Open with explorer
"   M   Mask mode
"
"   o   Double window filer
"   t   Open tree
"   T   Open tree recursively
"   ~   Open home directory
"   ¥   Open root directory
"   C-j History
"   C-g Display file name
"
"   Space Mark (Use on visual mode, too)
"   *   Mark all
"   U   Mark all off
"   c   Copy
"   m   Move
"   d   Delete
"   r   Rename
"
"   K   Create new direcotory
"   N   Create new file
"
"   H   Vimshell
"
"   q   Hide
"   q   Auit
"
"   s   Split
"   v   Vsplit
"   /   Migemo
"   J   mru
"   O   Sync
"   gy  Open in tab
"   p   Quick look

" -------------------------------------------

nnoremap <silent> <F6> :VimFilerBufferDir -simple -buffer-name=explorer -split -winwidth=31 -toggle -no-quit<cr>

" Unite buffer_tab -buffer-name=buflist -hide-source-names -hide-status-line -no-focus -resume -horizontal -auto-preview -auto-resize -toggle -no-quit -no-start-insert -winheight=10 -direction=leftbelow

"nmap    [Space]v   <Plug>(vimfiler_switch)
nnoremap <silent> <Space>v   :<C-u>VimFiler<CR>

nnoremap <silent> <F5> :<C-u>call <SID>toggle_vimfiler_explorer()<cr>
function! s:toggle_vimfiler_explorer()
  VimFilerExplorer -winwidth=33
  if &filetype == 'vimfiler'
    if exists('b:vimfiler')
          \ && !get(b:vimfiler, 'is_visible_dot_files', 1)
      execute 'normal .'
      " let b:vimfiler.is_visible_dot_files = 1
      " call vimfiler#redraw_screen()
    endif
  endif
  if &buftype ==# 'nofile' && bufname('') ==# '-MiniBufExplorer-'
    execute 'wincmd w'
  endif
endfunction

" 自動実行 - Helper
function! s:auto_open_vimfiler()
  call <SID>toggle_vimfiler_explorer()
  execute 'wincmd w'
  execute 'edit $MYVIMRC'
  augroup AutoOpenVimfilerAu
    autocmd!
  augroup END
  augroup! AutoOpenVimfilerAu
endfunction
" http://saihoooooooo.hatenablog.com/entry/2013/05/24/130744
function! s:GetBufByte()
  let byte = line2byte(line('$') + 1)
  if byte == -1
    return 0
  else
    return byte - 1
  endif
endfunction
" 自動実行 - Main
if has('vim_starting')
      \ && len(expand('%:p')) == 0
      \ && !argc()
  augroup AutoOpenVimfilerAu
    autocmd!
    autocmd VimEnter * nested
          \ if @% == '' && s:GetBufByte() == 0
          \ | call <SID>auto_open_vimfiler()
          \ | endif
  augroup END
endif

" Unite buffer_tab -buffer-name=buflist -hide-source-names -hide-status-line -no-focus -resume -horizontal -auto-preview -auto-resize -toggle -no-quit -no-start-insert -winheight=10 -direction=leftbelow
let bundle = neobundle#get('vimfiler')
function! bundle.hooks.on_source(bundle)
  let is_windows = has('win16') || has('win32') || has('win64')
  let is_cygwin = has('win32unix')
  let is_mac = !is_windows && !is_cygwin
        \ && (has('mac') || has('macunix') || has('gui_macvim')
        \ || (!executable('xdg-open') && system('uname') =~? '^darwin'))

  " let g:vimfiler_enable_clipboard = 0
  " let g:vimfiler_safe_mode_by_default = 0
  let g:vimfiler_time_format = '%Y/%m/%d %H:%M:%S'
  " let g:vimfiler_enable_auto_cd = 0
  " let g:vimfiler_default_columns = 'type:size:time'
  " let g:vimfiler_explorer_columns = 'type'

  " let g:vimfiler_edit_action = 'edit'

  let g:vimfiler_as_default_explorer = 1
  let g:vimfiler_detect_drives = is_windows ? [
        \ 'C:/', 'D:/', 'E:/', 'F:/', 'G:/', 'H:/', 'I:/',
        \ 'J:/', 'K:/', 'L:/', 'M:/', 'N:/'] :
        \ split(glob('/mnt/*'), '\n') + split(glob('/media/*'), '\n') +
        \ split(glob('/Users/*'), '\n')

  " %p : full path
  " %d : current directory
  " %f : filename
  " %F : filename removed extensions
  " %* : filenames
  " %# : filenames fullpath
  let g:vimfiler_sendto = {
        \ 'unzip' : 'unzip %f',
        \ 'zip' : 'zip -r %F.zip %*',
        \ 'Inkscape' : 'inkspace',
        \ 'GIMP' : 'gimp %*',
        \ 'gedit' : 'gedit',
        \ }

  if is_windows
    " Use trashbox.
    let g:unite_kind_file_use_trashbox = 1
  else
    let g:vimfiler_tree_leaf_icon = ' '
    let g:vimfiler_tree_opened_icon = '▾'
    let g:vimfiler_tree_closed_icon = '▸'
    let g:vimfiler_file_icon = '-'
    let g:vimfiler_readonly_file_icon = 'X'
    let g:vimfiler_marked_file_icon = '*'
  endif

  let g:vimfiler_quick_look_command =
        \ is_windows ? 'maComfort.exe -ql' :
        \ is_mac ? 'qlmanage -p' : 'gloobus-preview'


  autocmd MyAutoCmd FileType vimfiler call s:vimfiler_my_settings()
  function! s:vimfiler_my_settings()
    call vimfiler#set_execute_file('vim', 'vim')
    call vimfiler#set_execute_file('txt', 'vim')

    " Overwrite settings.
    nmap <buffer><expr> <cr> vimfiler#smart_cursor_map(
            \ '<Plug>(vimfiler_cd_file)',
            \ '<Plug>(vimfiler_edit_file)')
    nnoremap <buffer>s :call vimfiler#mappings#do_action('my_split')<cr>
    nnoremap <buffer>v :call vimfiler#mappings#do_action('my_vsplit')<cr>
    let s:my_action = { 'is_selectable' : 1 }
    function! s:my_action.func(candidates)
      wincmd p
      exec 'split '. a:candidates[0].action__path
    endfunction
    call unite#custom_action('file', 'my_split', s:my_action)
    unlet s:my_action

    let s:my_action = { 'is_selectable' : 1 }
    function! s:my_action.func(candidates)
      wincmd p
      exec 'vsplit '. a:candidates[0].action__path
    endfunction
    call unite#custom_action('file', 'my_vsplit', s:my_action)
    unlet s:my_action

    nmap <buffer> t <Plug>(vimfiler_expand_tree)

    nnoremap <silent><buffer> J
          \ <C-u>:Unite -buffer-name=files -default-action=lcd directory_mru<CR>

    nmap <buffer> O <Plug>(vimfiler_sync_with_another_vimfiler)
    nnoremap <silent><buffer><expr> gy vimfiler#do_action('tabopen')
    nmap <buffer> p <Plug>(vimfiler_quick_look)

    " Migemo search.
    if !empty(unite#get_filters('matcher_migemo'))
      nnoremap <silent><buffer><expr> /  line('$') > 10000 ?  'g/' :
            \ ":\<C-u>Unite -buffer-name=search -start-insert line_migemo\<CR>"
    endif
  endfunction
endfunction
unlet bundle
" }}}

" === vinarise.vim {{{
let g:vinarise_enable_auto_detect = 1
" }}}

" === YankRing.vim {{{
" 通常版のvimでは以下の設定にしないとペースト時にエラーが出る
if ! has('kaoriya')
  let g:yankring_manual_clipboard_check = 0
endif
" 履歴保存先を変更(デフォルトだと隠しファイルにならないため)
let g:yankring_history_file = ".yankring_history"
" Yankの履歴参照
nmap <Leader>y :YRShow<CR>
" ヤンク履歴についかする最少文字数(1文字は対象外)
let g:yankring_min_element_length = 2

let g:yankring_replace_n_nkey = ''
let g:yankring_replace_n_pkey = ''

autocmd MyAutoCmd BufNewFile *
      \ if bufname('%') ==# '[YankRing]'
      \ | setlocal nofoldenable nomodeline foldcolumn=0
      \ | endif
" }}}

" === watchdogs {{{
"  シンタックスチェックを実行
"    :WatchdogsRun
"  チェッカーを指定して実行
"    :WatchdogsRun watchdogs_checker/g++
"  :QuickRun と同様の引数を渡す
"    :WatchdogsRun watchdogs_checker/g++ -cmdopt -Wall
"------------------------------------

let bundle = neobundle#get('vim-watchdogs')
function! bundle.hooks.on_source(bundle)
  let g:watchdogs_filetype_checkers = {
        \  'coffee' : [ 'coffeelint', 'coffee' ],
        \  'python' : [ 'flake8', 'pyflakes', 'pep8' ],
        \}

  let g:watchdogs_quickrun_config = {
        \  'runner/vimproc/updatetime' : 40,
        \}

  let g:watchdogs_quickrun_post_config = {
        \  'hook/close_quickfix/enable_exit' : 0,
        \}

  let g:watchdogs_checkers = {
        \ 'jshint' : {
        \   'command' : 'jshint',
        \   'exec'    : '%c --verbose %s:p',
        \   'errorformat' : '%f: line %l\, col %c\, %m,%-G%.%#error%.%#,%-G',
        \  },
        \}

  " 自動実行
  " 全てのfiletypeを有効
  "let g:watchdogs_check_BufWritePost_enable = 0
  " filetype毎に指定
  let g:watchdogs_check_BufWritePost_enables = {
        \  'c'          : 0,
        \  'coffee'     : 3,
        \  'cpp'        : 0,
        \  'javascript' : 3,
        \  'perl'       : 1,
        \  'php'        : 1,
        \  'python'     : 3,
        \  'ruby'       : 1,
        \  'sass'       : 1,
        \  'scss'       : 1,
        \}

  " 一定時間キー入力がなかった場合にシンタックスチェックを行う
  " バッファに書き込み後、1度だけ行われる
  "let g:watchdogs_check_CursorHold_enable = 1
  " let g:watchdogs_check_CursorHold_enables = {
  "       \  "haskell" : 1,
  "       \  'coffee'  : 3,
  "       \}
endfunction
unlet bundle
" }}}

" === zencoding.vim {{{
let bundle = neobundle#get('zencoding-vim')
function! bundle.hooks.on_source(bundle)
  let g:user_zen_removetag_key = ''
  let g:use_zen_complete_tag = 1
  let g:user_zen_settings = {
  \  'lang' : 'ja',
  \  'html' : {
  \    'filters' : 'html',
  \    'snippets' : {
  \      'jq' : "<script src=\"https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js\"></script>\n<script>\n\\$(function() {\n\t|\n})()\n</script>",
  \      'cd' : "<![CDATA[|]]>",
  \    },
  \  },
  \  'perl' : {
  \    'aliases' : {
  \      'req' : "require '|'"
  \    },
  \    'snippets' : {
  \      'use' : "use strict\nuse warnings\n\n",
  \      'w' : "warn \"${cursor}\";",
  \    },
  \  },
  \  'php' : {
  \    'extends' : 'html',
  \    'filters' : 'html,c',
  \  },
  \  'javascript' : {
  \    'snippets' : {
  \      'jq' : "\\$(function() {\n\t\\${cursor}\\${child}\n});",
  \      'jq:json' : "\\$.getJSON(\"${cursor}\", function(data) {\n\t\\${child}\n});",
  \      'jq:each' : "\\$.each(data, function(index, item) {\n\t\\${child}\n});",
  \      'fn' : "(function() {\n\t\\${cursor}\n})();",
  \      'tm' : "setTimeout(function() {\n\t\\${cursor}\n}, 100);",
  \    },
  \    'use_pipe_for_cursor' : 0,
  \  },
  \  'css' : {
  \    'filters' : 'fc',
  \    'snippets' : {
  \      'box-shadow' : "-webkit-box-shadow: 0 0 0 # 000;\n-moz-box-shadow: 0 0 0 0 # 000;\nbox-shadow: 0 0 0 # 000;",
  \    },
  \  },
  \  'less' : {
  \    'filters' : 'fc',
  \    'extends' : 'css',
  \  },
  \ 'java' : {
  \  'snippets' : {
  \   'main': "public static void main(String[] args) {\n\t|\n}",
  \   'println': "System.out.println(\"|\");",
  \   'class': "public class | {\n}\n",
  \  },
  \ },
  \}
endfunction
unlet bundle
" }}}

" vim: fdm=marker:
