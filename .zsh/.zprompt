### zshプロンプト設定

# カラーの設定を$fg[red]のように人がわかるような書き方ができる
autoload -Uz colors
colors

# $WINDOWなどの環境変数をプロンプトに設定するために使用
setopt prompt_subst

## コマンド実行後右プロンプトを消す
#setopt transient_rprompt


#
# Color定義(あとで変更しやすいように)
#
DEFAULT=$'%{\e[0;0m%}'
RESET="%{${reset_color}%}"
GREEN="%{${fg[green]}%}"
BOLD_GREEN="%{${fg_bold[green]}%}"
BLUE="%{${fg[blue]}%}"
BOLD_BLUE="%{${fg_bold[blue]}%}"
RED="%{${fg[red]}%}"
BOLD_RED="%{${fg_bold[red]}%}"
CYAN="%{${fg[cyan]}%}"
BOLD_CYAN="%{${fg_bold[cyan]}%}"
YELLOW="%{${fg[yellow]}%}"
BOLD_YELLOW="%{${fg_bold[yellow]}%}"
MAGENTA="%{${fg[magenta]}%}"
BOLD_MAGENTA="%{${fg_bold[magenta]}%}"
WHITE="%{${fg[white]}%}"


## Set prompt for zsh
#
# PROMPT  : 通常のプロンプト
# PROMPT2 : forやwhile文使用時の複数行入力プロンプト
# RPROMPT : 右側に表示されるプロンプト, 入力が被ると自動的に消える
# SPROMPT : 入力ミス時のコマンド訂正プロンプト
#
# コマンド訂正プロンプト
#  y: 訂正コマンドを実行
#  n: 入力したコマンドが実行
#  a: 実行を中断 abort
#  e: コマンドライン編集 edit
#
# プロンプト文字列
#   %% : %文字
#   %# : #文字(一般ユーザなら %，スーパユーザなら #)
#   %l : tty名
#   %M : ホスト名（全部）
#   %m : ホスト名（最初のドットまで）
#   %n : ユーザ名
#   %? : 直前のコマンドの終了値($?)
#   %/ : カレントディレクトリ(フルパス)
#   %~ : 同上,ただし~記号などで可能な限り短縮する
#   %1~ or %1/ : カレントディレクトリ(ベースネーム)
#   %h or %! : Current history event number.
#   %l : The line (tty) the user is logged in on
#   %B : 太字開始
#   %b : 太字解除
#   %(1j,(%j),) : 実行中のジョブ数が1つ以上ある場合ジョブ数を表示
#
#   %{%(?.$fg[white].$fg[red])%}
#    直前の終了ステータスに応じてプロンプトの色が変化(0:白, 0以外:赤)
#    http://blog.8-p.info/2009/01/red-prompt
#
#   %D{%Y/%m/%d %H:%M:%S} : 時間表示(年/月/日 時:分:秒)
#
#   %(5~,%-2~/.../%2~,%~)%<space> : 長いディレクトリ名を省略表示
#
#   $WINDOW : screen 実行時のスクリーン番号
#



## rootユーザの場合(全て赤文字)
#   su - or sudo -s を行った場合は環境変数が引き継がれない

if [ ${UID} -eq 0 ]; then
    PROMPT="${RESET}${BOLD_RED}[%n@%m:%~]#$RESET} "
    PROMPT2="${RESET}${BOLD_RED}%_${RESET} "
    SPROMPT="${RESET}${RED}%r is correct? [n,y,a,e]:${RESET} "
    return 0
fi

## 一般ユーザの場合
#

# SSH接続時
#  HostのIPを環境変数に設定
#  http://d.hatena.ne.jp/kakurasan/20070611/p1
if [ -n "${SSH_CONNECTION}" ]; then
    export HOST_IP=$(echo ${SSH_CONNECTION} | awk -F\  '{printf "SSH("$1")"}')
fi

#
# tmuxのウィンドウ番号とペイン番号を環境変数に設定
#
_set_tmux_window() {
    if [ "$TMUX" ]; then
        #export TMUX_WINDOW=$(tmux list-windows 2> /dev/null | awk -F: '/\(active\)$/ \
        #{printf $1}')"-"$(tmux list-panes 2> /dev/null | awk -F: '/\(active\)$/ {printf $1}')

        # tmux display
        #   -p 標準出力へ
        #   -t 対象のペイン番号($TMUX_PANEなどを指定)
        export TMUX_WINDOW=$(tmux display -p '#I-#P')
    fi
}
add-zsh-hook precmd _set_tmux_window


## For zsh-git-prompt
if [ -f ~/.zsh/zsh-git-prompt/zshrc.sh ]; then
    source ~/.zsh/zsh-git-prompt/zshrc.sh
fi


#
# Prompt
#

PROMPT_NORMAL_SYMBOL="♪ "
PROMPT_ERROR_SYMBOL="✘ "

DEFAULT_PROMPT='${RESET}${BOLD_YELLOW}${HOST_IP:+"${HOST_IP}>"}${RESET}[${BOLD_BLUE}${WINDOW:+"#$WINDOW "}${TMUX_WINDOW:+"$TMUX_WINDOW "}${RESET}${BOLD_GREEN}%n${RESET}${GREEN}❖ ${RESET}${BOLD_GREEN}%m${RESET}${RED}%(1j,(%j),)${RESET}:${CYAN}%~${RESET}]%(?.${BLUE}${PROMPT_NORMAL_SYMBOL}.${RED}${PROMPT_ERROR_SYMBOL}) ${RESET}'

# For tmux-powerline
DEFAULT_PROMPT="$DEFAULT_PROMPT"'$([ -n "$TMUX" ] && tmux setenv TMUXPWD_$(tmux display -p "#I_#P") "$PWD")'

VI_CMD_PROMPT='${RESET}${BOLD_YELLOW}${HOST_IP:+"${HOST_IP}>"}${RESET}[${BOLD_BLUE}${WINDOW:+"#$WINDOW "}${TMUX_WINDOW:+"$TMUX_WINDOW "}${RESET}${YELLOW}%n@%m${RESET}${RED}%(1j,(%j),)${RESET}:${CYAN}%~${RESET}]%{%(?.${WHITE}.${RED}%}♪ ${RESET}'

PROMPT=${DEFAULT_PROMPT}
SPROMPT="${RESET}${RED}%r is correct? [n,y,a,e]:${RESET} "

#
# Vi入力モードでPROMPTの色を変える
# http://memo.officebrook.net/20090226.html
#
function zle-line-init zle-keymap-select {
    case $KEYMAP in
    vicmd)
        # viコマンドモード
        PROMPT=${VI_CMD_PROMPT}
        ;;
    main|viins)
        # viインサートモード
        PROMPT=${DEFAULT_PROMPT}
        ;;
    esac
    zle reset-prompt
}
zle -N zle-line-init
zle -N zle-keymap-select


#
# VCS_INFO
#  http://zsh.sourceforge.net/Doc/Release/User-Contributions.html#SEC273
#  https://github.com/olivierverdier/zsh-git-prompt
#  http://d.hatena.ne.jp/mollifier/20100906/p1
#  http://d.hatena.ne.jp/yuroyoro/20110219/1298089409
#  http://d.hatena.ne.jp/pasela/20110216/git_not_pushed
#  http://liosk.blog103.fc2.com/blog-entry-209.html
#

# git status symbol
VCS_SIGIL="∇ "
VCS_STAGED_SIGIL="● "
VCS_UNSTAGED_SIGIL="✚ "
VCS_UNTRACKED_SIGIL="… "
VCS_STASHED_SIGIL="⚑"
VCS_CLEAN_SIGIL="✔ "
VCS_NOT_PUSHED_SIGIL="*"
VCS_CONFLICTS_SIGIL="✖ "

# color settings
VCS_NAME_COLOR="%{%B%F{yellow}%}"
VCS_BRANCH_COLOR="%{%B%F{red}%}"
VCS_ACTION_COLOR="%{%B%F{red}%}"
VCS_STAGED_COLOR="%{%F{blue}%}"
VCS_UNSTAGED_COLOR="%{%F{yellow}%}"
VCS_UNTRACKED_COLOR=
VCS_STASHED_COLOR="%{%F{cyan}%}"
VCS_CLEAN_COLOR="%{%B%F{green}%}"
VCS_NOT_PUSHED_COLOR=
VCS_CONFLICTS_COLOR="%{%F{red}%}"


autoload -Uz vcs_info

zstyle ':vcs_info:*' enable git svn hg bzr

# formatsのプレースホルダの最大値
zstyle ':vcs_info:*' max-exports 7

# hg で check-for-changes を有効にするために必要
zstyle ':vcs_info:hg:*' get-revision true
zstyle ':vcs_info:hg:*' use-simple true

#
# フォーマットに指定できる変数
#   %s : The VCS in use (git, hg, svn, etc.).
#   %b : Information about the current branch.
#   %a : An identifier that describes the action. Only makes sense in actionformats.
#   %r : The repository name. If %R is /foo/bar/repoXY, %r is repoXY.
#   %c : The string from the stagedstr style if there are staged changes in the repository.
#   %u : The string from the unstagedstr style if there are unstaged changes in the repository.
#

# 左から順番に、vcs_info_msg_{n}_ という変数に格納される
zstyle ':vcs_info:*' formats '(%s)-[%b]'
zstyle ':vcs_info:*' actionformats '(%s)-[%b|%a]'
zstyle ':vcs_info:(svn|bzr):*' branchformat '%b:%r'

autoload -Uz is-at-least
if is-at-least 4.3.10; then
    # zshが4.3.10以上の場合
    zstyle ':vcs_info:git:*' check-for-changes true
    zstyle ':vcs_info:git*:*' stagedstr "${VCS_STAGED_COLOR}${VCS_STAGED_SIGIL}"
    zstyle ':vcs_info:git*:*' unstagedstr "${VCS_UNSTAGED_COLOR}${VCS_UNSTAGED_SIGIL}"
    zstyle ':vcs_info:git:*' formats '%s' '${VCS_BRANCH_COLOR}%b${RESET}' '%c' '%u'
    zstyle ':vcs_info:git:*' actionformats '${VCS_NAME_COLOR}%s${RESET}' '${VCS_BRANCH_COLOR}%b%{RESET}:${VCS_ACTION_COLOR}%a${RESET}' '%c' '%u'
fi


function _update_vcs_info_msg() {
    # カレントがgitレポジトリ下かどうか判定
    if [ "$(git rev-parse --is-inside-work-tree 2> /dev/null)" = "true" ]; then
        # zsh-git-prompt
        if type git_super_status >/dev/null 2>&1; then
            RPROMPT="${RESET}$(git_super_status)${RESET}${BOLD_YELLOW}${VIRTUAL_ENV:+($(basename "$VIRTUAL_ENV"))}${RESET}[${MAGENTA}%D{%Y/%m/%d %H:%M:%S}${RESET}]${RESET}"
            return 0
        fi
    fi

    # zsh-git-promptが使用できない場合
    psvar=()
    LANG=en_US.UTF-8 vcs_info

    local _status
    if [ "$vcs_info_msg_0_" = "git" ]; then
        _status="(${VCS_NAME_COLOR}$vcs_info_msg_0_${RESET})-[$(_check_git_status)${RESET}]"
    else
        _status="${VCS_NAME_COLOR}$vcs_info_msg_0_${RESET}"
    fi

    # 右側プロンプト
    RPROMPT="${RESET}${_status}${RESET}${BOLD_YELLOW}${VIRTUAL_ENV:+($(basename "$VIRTUAL_ENV"))}${RESET}[${MAGENTA}%D{%Y/%m/%d %H:%M:%S}${RESET}]${RESET}"
}
add-zsh-hook precmd _update_vcs_info_msg


function _check_git_status() {
    local branch="$vcs_info_msg_1_"
    local staged="$vcs_info_msg_2_"
    local unstaged="$vcs_info_msg_3_"
    local untracked="${VCS_UNTRACKED_COLOR}${VCS_UNTRACKED_SIGIL}"
    local stashed="${VCS_STASHED_COLOR}${VCS_STASHED_SIGIL}"
    local conflicts="${VCS_CONFLICTS_COLOR}${VCS_CONFLICTS_SIGIL}"
    local not_pushed="${VCS_NOT_PUSHED_COLOR}${VCS_NOT_PUSHED_SIGIL}${RESET}"
    local clean="${VCS_CLEAN_COLOR}${VCS_CLEAN_SIGIL}${RESET}"

    local conflicts_count=0

    # staged
    local staged_files="$(git diff --staged --name-status)"
    if [ -n "$staged_files" ];then
        conflicts_count=$(echo "$staged_files" | sed '/^[^U]/d' | wc -l | sed 's/ //g')
        staged_count=$(echo "$staged_files" | wc -l | sed 's/ //g')
        staged_count=$(($staged_count - $conflicts_count))

        if [ -z "$staged" ];then
            # stagedな新規ファイルがvcs_infoで検出されない
            # (only Initial commit)
            staged="${VCS_STAGED_COLOR}${VCS_STAGED_SIGIL}"
        fi
        staged="$staged$staged_count${RESET}"
    fi

    # conflicts
    if [ "$conflicts_count" -gt 0 ]; then
        conflicts="$conflicts$conflicts_count${RESET}"
    else
        conflicts=""
    fi

    # unstaged
    local unstaged_files="$(git diff --name-status)"
    if [ -n "$unstaged_files" ]; then
        unstaged_count=$(echo "$unstaged_files" | sed '/^U/d' | wc -l | sed 's/ //g')
        unstaged="$unstaged$unstaged_count${RESET}"
    fi

    # untracked
    untracked_files=$(git ls-files --others --exclude-standard)
    if [ -n "$untracked_files" ]; then
        untracked_count=$(echo "$untracked_files" | wc -l | sed 's/ //g')
        untracked="$untracked$untracked_count${RESET}"
    else
        untracked=""
    fi

    # HEADのハッシュ値を取得
    #  --verify 有効なオブジェクト名として使用できるかを検証
    #  --quiet  --verifyと共に使用し、無効なオブジェクトが指定された場合でもエラーメッセージを出さない
    #           そのかわり終了ステータスを0以外にする
    local head="$(git rev-parse --verify -q HEAD 2> /dev/null)"
    if [ $? -eq 0 ]; then
        # HEADのハッシュ値取得に成功
        # リモートのハッシュ値を配列で取得
        remotes=($(git rev-parse --remotes 2> /dev/null))
        if [ "$remotes[*]" ]; then
            # リモートのハッシュ値取得に成功(リモートが存在する)
            for x in ${remotes[@]}; do
                # リモートとHEADのハッシュ値が一致するか判定
                if [ "$head" = "$x" ]; then
                    # 一致した場合はPUSH済み
                    not_pushed=""
                    break
                fi
            done
        else
            # リモートが存在しない場合
            not_pushed=""
        fi
    else
        # HEADが存在しない場合(init直後など)
        not_pushed=""
    fi

    # stash
    local stash_list="$(git stash list)"
    if [ -n "$stash_list" ]; then
        stashed_count=$(echo "$stash_list" | wc -l | sed 's/ //g')
        stashed="$stashed$stashed_count${RESET}"
    else
        stashed=""
    fi

    local git_status="${not_pushed}${branch}|${staged}${unstaged}${untracked}${conflicts}${stashed}"

    if [ -z "$staged" -a -z "$unstaged" -a -z "$untracked" -a -z "$conflicts" ]; then
        git_status="${git_status}${clean}"
    fi

    echo "$git_status"
}

# vim: ft=zsh
