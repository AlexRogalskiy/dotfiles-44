"=== Introduction ========================================================={{{
"
"  .vimrc.neocomplete
"
"   neocomplete.vim settings
"
"   https://github.com/Shougo/neocomplete
"
"
"   補完候補のPrefix
"    file              -> [F] {filename}
"    file/include      -> [FI] {filename}
"    dictionary        -> [D] {words}
"    member            -> [M] member
"    buffer            -> [B] {buffername}
"    syntax            -> [S] {syntax-keyword}
"    include           -> [I]
"    neosnippet        -> [neosnip]
"    UltiSnips         -> [US]
"    vim               -> [vim] type
"    omni              -> [O]
"    tag               -> [T]
"    other sources     -> [plugin-name-prefix]
"
"
"==========================================================================}}}


if neobundle#tap('neocomplete')

"Note: This option must set it in .vimrc(_vimrc).  NOT IN .gvimrc(_gvimrc)!
" Disable AutoComplPop.

let g:acp_enableAtStartup = 0
" Use neocomplete.
let g:neocomplete#enable_at_startup = 1


function! neobundle#hooks.on_source(bundle)


  " === Basic {{{2

  " Use smartcase.
  let g:neocomplete#enable_smart_case = 1

  " Set minimum syntax keyword length. (default: 4)
  let g:neocomplete#sources#syntax#min_keyword_length = 3

  " neocomplcacheを自動的にロックするバッファ名のパターン
  " ku.vimやfuzzyfinderなど、neocomplcacheと相性が悪いプラグインを使用する場合に設定
  let g:neocomplete#lock_buffer_name_pattern = '\*ku\*'

  " CamelCase の補完を有効化
  let g:neocomplete#enable_camel_case = 1

  let g:neocomplete#enable_auto_delimiter = 1

  if !exists('g:neocomplete#delimiter_patterns')
    let g:neocomplete#delimiter_patterns= {}
  endif
  let g:neocomplete#delimiter_patterns.vim = ['#']
  let g:neocomplete#delimiter_patterns.cpp = ['::']
  let g:neocomplete#delimiter_patterns.php = ['->', '::', '\']

  " }}}


  " === Dictionary completion {{{2

  " vimのデフォルト辞書を指定
  set dictionary&
        \ dictionary+=~/.vim/dict/_.dict,~/dotfiles.local/.vim/dict/_.dict

  " Define dictionary.
  let g:neocomplete#sources#dictionary#dictionaries = {
        \ '_'            : expand('$DOTVIM/dict/_.dict').','.expand('~/dotfiles.local/.vim/dict/_.dict'),
        \ 'default'      : '',
        \ 'scala'        : expand('$DOTVIM/bundle/vim-scala/dict/scala.dict'),
        \ 'java'         : expand('$DOTVIM/dict/java.dict'),
        \ 'c'            : expand('$DOTVIM/dict/c.dict'),
        \ 'cpp'          : expand('$DOTVIM/dict/cpp.dict'),
        \ 'css'          : expand('$DOTVIM/dict/css.dict'),
        \ 'javascript'   : expand('$DOTVIM/dict/javascript.dict'),
        \ 'ocaml'        : expand('$DOTVIM/dict/ocaml.dict'),
        \ 'perl'         : expand('$DOTVIM/dict/perl.dict'),
        \ 'php'          : expand('$DOTVIM/dict/php.dict'),
        \ 'scheme'       : expand('$DOTVIM/dict/scheme.dict'),
        \ 'vim'          : expand('$DOTVIM/dict/vim.dict'),
        \ 'vimshell'     : expand('~/.vimshell_hist'),
        \ 'int-termtter' : expand('~/.vimshell/int-history/int-termtter'),
        \ }

  if !exists('g:neocomplete#same_filetypes')
    let g:neocomplete#same_filetypes = {}
  endif

  let g:neocomplete#same_filetypes.bash = 'sh'
  let g:neocomplete#same_filetypes.c = 'cpp,d'
  let g:neocomplete#same_filetypes.coffee = 'javascript,jquery'
  let g:neocomplete#same_filetypes.cpp = 'c'
  let g:neocomplete#same_filetypes.erlang = 'man'
  let g:neocomplete#same_filetypes.gitconfig = '_'
  let g:neocomplete#same_filetypes.javascript = 'jquery'
  let g:neocomplete#same_filetypes.jquery = 'javascript'
  let g:neocomplete#same_filetypes.less = 'css'
  let g:neocomplete#same_filetypes.objc = 'c'
  let g:neocomplete#same_filetypes.perl = 'ref,man'
  let g:neocomplete#same_filetypes.tt2html = 'html,perl'
  let g:neocomplete#same_filetypes.zsh = 'sh'
  let g:neocomplete#same_filetypes._ = '_'

  " }}}


  " === Keyword completion {{{2

  " Define keyword.
  if !exists('g:neocomplete#keyword_patterns')
      let g:neocomplete#keyword_patterns = {}
  endif

  let g:neocomplete#keyword_patterns.default = '\h\w*'
  let g:neocomplete#keyword_patterns.perl = '\h\w*->\h\w*\|\h\w*::'
  let g:neocomplete#keyword_patterns.coffee = '\h\w*@\h\w*'

  " }}}


  " === Omni completion {{{2

  " Enable omni completion.
  autocmd MyAutoCmd FileType javascript     setlocal omnifunc=tern#Complete
  autocmd MyAutoCmd FileType coffee         setlocal omnifunc=javascriptcomplete#CompleteJS
  autocmd MyAutoCmd FileType html,markdown  setlocal omnifunc=htmlcomplete#CompleteTags
  autocmd MyAutoCmd FileType css,less       setlocal omnifunc=csscomplete#CompleteCSS
  autocmd MyAutoCmd FileType xml            setlocal omnifunc=xmlcomplete#CompleteTags
  autocmd MyAutoCmd FileType php            setlocal omnifunc=phpcomplete#CompletePHP
  autocmd MyAutoCmd FileType c              setlocal omnifunc=ccomplete#Complete
  autocmd MyAutoCmd FileType ruby           setlocal omnifunc=rubycomplete#Complete


  " Enable heavy omni completion.
  if !exists('g:neocomplete#sources#omni#input_patterns')
    let g:neocomplete#sources#omni#input_patterns = {}
  endif

  let g:neocomplete#sources#omni#input_patterns.ruby = '[^. *\t]\.\h\w*\|\h\w*::'
  "let g:neocomplete#sources#omni#input_patterns.php = '[^. \t]->\h\w*\|\h\w*::'
  "let g:neocomplete#sources#omni#input_patterns.c = '[^.[:digit:] *\t]\%(\.\|->\)'
  "let g:neocomplete#sources#omni#input_patterns.cpp = '[^.[:digit:] *\t]\%(\.\|->\)\|\h\w*::'

  " For perlomni.vim setting.
  " https://github.com/c9s/perlomni.vim
  let g:neocomplete#sources#omni#input_patterns.perl = '\h\w*->\h\w*\|\h\w*::'

  if !exists('g:neocomplete#force_omni_input_patterns')
    let g:neocomplete#force_omni_input_patterns = {}
  endif
  let g:neocomplete#force_omni_input_patterns.python =
        \ '\%([^. \t]\.\|^\s*@\|^\s*from\s.\+import \|^\s*from \|^\s*import \)\w*'
  " let g:neocomplete#sources#omni#input_patterns.php =
  "       \ '[^. \t]->\%(\h\w*\)\?\|\h\w*::\%(\h\w*\)\?'
  " let g:neocomplete#force_omni_input_patterns.ruby =
  "       \ '[^. *\t]\.\w*\|\h\w*::'

 " clang_completion
  " let g:neocomplete#force_overwrite_completefunc = 1
  " let g:neocomplete#sources#omni#input_patterns.c =
  "       \ '[^.[:digit:] *\t]\%(\.\|->\)\%(\h\w*\)\?'
  " let g:neocomplete#sources#omni#input_patterns.cpp =
  "       \ '[^.[:digit:] *\t]\%(\.\|->\)\%(\h\w*\)\?\|\h\w*::\%(\h\w*\)\?'
  " let g:neocomplete#force_omni_input_patterns.objc =
  "       \ '\[\h\w*\s\h\?\|\h\w*\%(\.\|->\)'
  " let g:neocomplete#force_omni_input_patterns.objcpp =
  "       \ '\[\h\w*\s\h\?\|\h\w*\%(\.\|->\)\|\h\w*::\w*'
  " let g:clang_complete_auto = 0
  " let g:clang_auto_select = 0
  " let g:clang_use_library = 1


  if !exists('g:neocomplete#sources#vim#complete_functions')
    let g:neocomplete#sources#vim#complete_functions = {}
  endif
  let g:neocomplete#sources#vim#complete_functions.Ref = 'ref#complete'

  " }}}


  " === Mappings {{{2

  " necomplete有効/無効
  nnoremap <Space>neot :NeoCompleteToggle

  " <C-h>, <BS>: close popup and delete backword char.
  inoremap <expr><C-h>  neocomplete#smart_close_popup()."\<C-h>"
  inoremap <expr><BS>   neocomplete#smart_close_popup()."\<BS>"
  inoremap <expr><C-y>  neocomplete#close_popup()
  inoremap <expr><C-e>  neocomplete#cancel_popup()

  " undo
  inoremap <expr><C-g>     neocomplete#undo_completion()
  " <C-l> : 補完候補の共通部分までを補完する
  inoremap <expr><C-l>     neocomplete#complete_common_string()

  " C-nでneocomplcache補完
  inoremap <expr><C-n> pumvisible() ? "\<C-n>" : "\<C-x>\<C-u>\<C-p>"

  inoremap <expr><Tab>  neocomplete#start_manual_complete()

  " ファイル名補完
  inoremap <expr><C-x><C-f>  neocomplete#start_manual_complete('file')

  " オムニ補完の手動呼び出し
  inoremap <expr><C-x><C-o> &filetype == 'vim' ? "\<C-x><C-v><C-p>" : neocomplete#start_manual_complete('omni')

  " <TAB>: completion.
  inoremap <expr><TAB>  pumvisible() ? "\<C-n>" : "\<TAB>"

  " C-n: completion.
  inoremap <expr><C-n>  pumvisible() ? "\<C-n>" : "\<C-x>\<C-u>\<C-p>"
  " C-p: completion
  "inoremap <expr><C-p> pumvisible() ? "\<C-p>" : "\<C-p>\<C-n>"

  " Close popup by <Space>.
  "inoremap <expr><Space> pumvisible() ? neocomplete#close_popup() : "\<Space>"

  " For cursor moving in insert mode(Not recommended)
  inoremap <expr><Left>  neocomplete#close_popup() . "\<Left>"
  inoremap <expr><Right> neocomplete#close_popup() . "\<Right>"
  "inoremap <expr><Up>    neocomplete#close_popup() . "\<Up>"
  "inoremap <expr><Down>  neocomplete#close_popup() . "\<Down>"

  " }}}


  " === Utility {{{2

  " ファイル名を取得
  "   http://d.hatena.ne.jp/cooldaemon/searchdiary?word=snippets
  function! Filename(...)
    let filename = expand('%:t:r')
    if filename == '' | return a:0 == 2 ? a:2 : '' | endif
    return !a:0 || a:1 == '' ? filename : substitute(a:1, '$1', filename, 'g')
  endf

  " bufferを開いたらキャッシュ
  " autocmd MyAutoCmd BufReadPost,BufEnter,BufWritePost :NeoCompleteBufferMakeCache <buffer>

  " manpageview のキーワードをキャッシュ
  "autocmd MyAutoCmd BufFilePost Manpageview* silent execute ":NeoCompleteBufferMakeCache"

  function! CompleteFiles(findstart, base)
    if a:findstart
      " Get cursor word.
      let cur_text = strpart(getline('.'), 0, col('.') - 1)

      return match(cur_text, '\f*$')
    endif

    let words = split(expand(a:base . '*'), '\n')
    let list = []
    let cnt = 0
    for word in words
      call add(list, {
            \ 'word' : word,
            \ 'abbr' : printf('%3d: %s', cnt, word),
            \ 'menu' : 'file_complete'
            \ })
      let cnt += 1
    endfor

    return { 'words' : list, 'refresh' : 'always' }
  endfunction

  " }}}

endfunction
call neobundle#untap()
endif

" vim: fdm=marker:
