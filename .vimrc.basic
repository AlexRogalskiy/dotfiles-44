"------------------------------------------------------------------------------
"
"  .vimrc.basic
"
"------------------------------------------------------------------------------

"### Basic {{{
"-------------------------------------------------------------------------------
"set shortmess+=I                " 起動時のメッセージを表示しない
set nocompatible                 " viとの互換性をとらない(vimの独自拡張機能を使う為)
let mapleader = ","              " キーマップリーダー
set scrolloff=5                  " スクロール時の余白確保
set textwidth=0                  " 入力されているテキストの最大幅 (0指定で折り返し表示を無効)
set wrap                         " ウィンドウの幅より長い行は折り返し表示
set autoread                     " 他で書き換えられたら自動で読み直す
set noswapfile                   " スワップファイル作らない

" 編集中でも他のファイルを開けるようにする(バッファを切替えてもundoの効力を失わない)
set hidden

" バックスペースキーで削除できるものを指定
"  indent  : 行頭の空白
"  eol     : 改行
"  start   : 挿入モード開始位置より手前の文字
set backspace=indent,eol,start   " バックスペースでなんでも消せるように

set formatoptions=lmoq           " テキスト整形オプション，マルチバイト系を追加
set vb t_vb=                     " ビープ音を鳴らさない
set browsedir=buffer             " Exploreの初期ディレクトリ
"set whichwrap=b,s,h,l,<,>,[,]    " カーソルを行頭、行末で止まらないようにする
set viminfo='50,<1000,s100,\"50  " viminfoファイルの設定

" モードライン
" 末尾にモードライン以外の文字を含めない場合
"  # vim: ft=sh sw=4 sts=4 ts=4 et
" 末尾にモードライン以外の文字を含める場合
"  /* vim: set ft=c sw=4 sts=4 ts=4 et: */
set modeline                     " モードラインを有効
set modelines=2                  " モードラインを認識する行数

" OSのクリップボードを使用 ヤンクした文字をクリップボードへ
set clipboard+=unnamedplus,unnamed

" xではクリップボードに入れない
" http://vivi.dyndns.org/SPR/SPR.phtml?project=ViVi210xx&sprID=40
" YankRingがあるとこの設定はできない
" ClipMenuの除外対象APL+YankRingの最少文字数で対応
"nnoremap <silent>x "_x

" ターミナルでマウスを使用できるようにする
" http://vim-users.jp/2009/12/hack107/
set mouse=a
" 通常版vimではマウス選択によるビジュアルモード機能を無効にする
if ! has("kaoriya")
  set mouse-=a
endif
set ttymouse=xterm2              " screenでもマウスを使用できるように

" 挿入モードでCtrl+kを押すとクリップボードの内容を貼り付けられるようにする "
"imap <C-k>  <ESC>"*pa

" vimrcの編集と反映
command! Ev edit $MYVIMRC
command! Sv source $MYVIMRC
nnoremap <Space>. :<C-u>edit $MYVIMRC<Enter>
nnoremap <Space>s. :<C-u>source $MYVIMRC<Enter>

" ファイルタイプ判定をon
filetype plugin on


"### Backup
set nobackup                     " バックアップをとらない
" ファイルの上書きの前にバックアップを作る
" (ただし、backup がオンでない限り、バックアップは上書きに成功した後削除される)
set writebackup

" " バックアップをとる場合
" "set backup
" " バックアップファイルを作るディレクトリ
" "set backupdir=~/backup
" " スワップファイルを作るディレクトリ
" "set directory=~/swap

" }}}


"### Apperance {{{
"-------------------------------------------------------------------------------
set title                        " タイトルをウインドウ枠に表示する
set showmatch                    " 括弧の対応をハイライト
set matchtime=1                  " 対応する括弧の表示時間
set number                       " 行番号表示
set list                         " 不可視文字表示:タブ文字を CTRL-I、行末を $ で表示する
set listchars=tab:>.,trail:_,extends:>,precedes:< " 不可視文字の表示形式
set display=uhex                 " 印字不可能文字を16進数で表示
set splitbelow                   " 横分割時に新しいウィンドウをカレントウィンドウの下に開く
set splitright                   " 縦分割時に新しいウィンドウをカレントウィンドウの右に開く

" コマンド実行中は再描画しない
set lazyredraw
" 高速ターミナル接続を行う
set ttyfast

" モードによってカーソルの形を変更
" 思ったより見づらかったので不可
" t_SI:StartInsert  t_EI:EndInsert
"let &t_SI = "\<Esc>]50;CursorShape=1\x7"
"let &t_EI = "\<Esc>]50;CursorShape=0\x7"

" テキストの折り返し表示のON/OFF
nnoremap <Space>ow :<C-u>setlocal wrap! \| setlocal wrap?<CR>

" }}}


"### Colors {{{
"-------------------------------------------------------------------------------
" シンタックスON
syntax enable

" ターミナルタイプによるカラー設定
if &term =~ "xterm-256color" || &term=~"screen-256color"
  " 256色
  set t_Co=256
  set t_Sf=^[[3%dm
  set t_Sb=^[[4%dm

  " カラー設定読み込み
  if $ITERM_PROFILE =~ "Magica.*"
    source ~/.vim/colors/my-magica.vim
  elseif $ITERM_PROFILE =~ "Solarized.*"
    source ~/.vim/colors/my-solarized.vim
  else
    source ~/.vim/colors/my-magica.vim
  endif

elseif &term =~ "xterm-debian" || &term =~ "xterm-xfree86"
  set t_Co=16
  set t_Sf=^[[3%dm
  set t_Sb=^[[4%dm
  " カラー設定読み込み
  source ~/.vim/colors/my-solarized.vim
elseif &term =~ "xterm-color"
  set t_Co=8
  set t_Sf=^[[3%dm
  set t_Sb=^[[4%dm
  " カラー設定読み込み
  source ~/.vim/colors/my-solarized.vim
endif


" user peculiar setting          " TeraTerm時有効設定
"set term=builtin_linux          " TeraTerm時有効設定
"set ttytype=builtin_linux       " TeraTerm時有効設定


" ---------- 他のカラー設定をここより前に書かない ----------

" 全角スペースの表示：ハイライト
highlight ZenkakuSpace cterm=underline ctermfg=blue ctermbg=gray gui=underline guifg=blue guibg=gray
match ZenkakuSpace /　/

" カラーカラムを表示する列
set colorcolumn=80


"### カーソル行ハイライト
set cursorline
" カレントウィンドウにのみ罫線を引く
augroup cch
  autocmd! cch
  autocmd WinLeave * set nocursorline
  autocmd WinEnter,BufRead * set cursorline
augroup END

" }}}


"### StatusLine {{{
"-------------------------------------------------------------------------------
set showcmd                      " 入力中のコマンドをステータスに表示する
set showmode                     " 現在のモードを表示
set laststatus=2                 " 常にステータスラインを表示
set cmdheight=2                  " コマンドラインの高さ

" カーソルが何行目の何列目に置かれているかを表示する
set ruler


" vim-powerlineを使用しない場合は以下の設定使用
" ステータスラインに表示する情報の指定
"set statusline=%n\:%y%F\ \|%{(&fenc!=''?&fenc:&enc).'\|'.&ff.'\|'}%m%r%=%3l/%-3L,%3v
" ステータスラインの色
"highlight StatusLine term=none guifg=Black guibg=Gray gui=none ctermfg=Black ctermbg=Gray cterm=none

"入力モード時、ステータスラインのカラーを変更
"augroup InsertHook
 "autocmd!
 "autocmd InsertEnter * highlight StatusLine guifg=Black    guibg=DarkYellow gui=none ctermfg=Black    ctermbg=DarkYellow cterm=none
 "autocmd InsertLeave * highlight StatusLine guifg=DarkBlue guibg=Gray       gui=none ctermfg=DarkBlue ctermbg=Gray       cterm=none
 ""autocmd InsertEnter * highlight StatusLine guifg=#ccdc90 guibg=#2E4340 ctermfg=cyan
 ""autocmd InsertLeave * highlight StatusLine guifg=#2E4340 guibg=#ccdc90 ctermfg=white
"augroup END

" }}}


"### Indent {{{
"-------------------------------------------------------------------------------
" 自動でインデント
set autoindent
" ペースト時にautoindentを無効(onにするとautocomplpop.vimが動かない)
"set paste
" 新しい行を開始したときに、新しい行のインデントを現在行と同じ量にする。
set smartindent
" Cプログラム形式の自動インデント
set cindent

" タブが対応する空白数
set tabstop=4
" cindentやautoindent時に挿入されるインデント幅(空白数)
set shiftwidth=4
" Tabキー押し下げ時に挿入される空白数，0の場合はtabstopと同じ，BSにも影響
set softtabstop=4
" タブを挿入するとき、代わりに空白を使わない
" 行頭の余白内で Tab を打ち込むと、'shiftwidth' の数だけインデント
" 行頭以外では 'tabstop' の数だけ空白を挿入
set smarttab
" タブを挿入するとき、代わりに空白を使う
set expandtab
"set noexpandtab

" ビジュアルモードでのインデント変更後も選択を継続
vnoremap < <gv
vnoremap > >gv

if has("autocmd")
  "ファイルタイプの検索を有効にする
  " .vim/ftplugin 配下にファイルタイプ毎に読み込ませる設定ファイルを配置可能
  filetype plugin on
  "そのファイルタイプにあわせたインデントを利用する
  filetype indent on
  " インデントを無効
  "autocmd FileType php filetype indent off

  " sw  : shiftwidth (インデント時に使用されるスペースの数)
  " sts : softtabstop (0でないなら、タブを入力時、その数値分だけ半角スペースを挿入)
  " ts  : tabstop (タブを画面で表示する際の幅)
  " et  : expandtab (有効時、タブを半角スペースとして挿入)
  " modeline : モードラインを有効
  " http://nanasi.jp/articles/howto/file/modeline.html
  autocmd FileType apache     setlocal sw=4 sts=4 ts=4 et
  autocmd FileType aspvbs     setlocal sw=4 sts=4 ts=4 et
  autocmd FileType c          setlocal sw=4 sts=4 ts=4 et
  autocmd FileType cpp        setlocal sw=4 sts=4 ts=4 et
  autocmd FileType cs         setlocal sw=4 sts=4 ts=4 et
  autocmd FileType csh        setlocal sw=4 sts=4 ts=4 et
  autocmd FileType css        setlocal sw=2 sts=2 ts=2 et
  autocmd FileType diff       setlocal sw=4 sts=4 ts=4 et
  autocmd FileType eruby      setlocal sw=4 sts=4 ts=4 et
  autocmd FileType gitcommit  setlocal sw=4 sts=4 ts=4 et nomodeline textwidth=72
  autocmd FileType gitconfig  setlocal sw=2 sts=2 ts=2 et
  autocmd FileType haml       setlocal sw=2 sts=2 ts=2 et
  autocmd FileType html       setlocal sw=2 sts=2 ts=2 et
  autocmd FileType java       setlocal sw=4 sts=4 ts=4 noet
  autocmd FileType javascript setlocal sw=2 sts=2 ts=2 et
  autocmd FileType make       setlocal sw=4 sts=4 ts=4 noet
  autocmd FileType perl       setlocal sw=4 sts=4 ts=4 et
  autocmd FileType php        setlocal sw=4 sts=4 ts=4 et
  autocmd FileType python     setlocal sw=4 sts=4 ts=8 et textwidth=80
  autocmd FileType ruby       setlocal sw=2 sts=2 ts=2 et
  autocmd FileType scala      setlocal sw=2 sts=2 ts=2 et
  autocmd FileType sh         setlocal sw=4 sts=4 ts=4 et
  autocmd FileType sql        setlocal sw=4 sts=4 ts=4 et
  autocmd FileType vb         setlocal sw=4 sts=4 ts=4 et
  autocmd FileType vim        setlocal sw=2 sts=2 ts=2 et
  autocmd FileType wsh        setlocal sw=4 sts=4 ts=4 et
  autocmd FileType xhtml      setlocal sw=4 sts=4 ts=4 et
  autocmd FileType xml        setlocal sw=4 sts=4 ts=4 et
  autocmd FileType yaml       setlocal sw=2 sts=2 ts=2 et
  autocmd FileType zsh        setlocal sw=4 sts=4 ts=4 et

  " インデント無効
  autocmd FileType html :set indentexpr=
  autocmd FileType xhtml :set indentexpr=
endif

" }}}


"### Completion {{{
"-------------------------------------------------------------------------------
set wildmenu               " コマンド補完を強化
set wildchar=<tab>         " コマンド補完を開始するキー
" コマンド補完候補が複数ある場合：リスト表示，共通する最長の文字列まで補完
set wildmode=list:longest
set history=1000           " コマンド・検索パターンの履歴数
set complete+=k            " 補完に辞書ファイル追加
set completeopt=menuone,preview  " 補完形式 (menu/menuone/longest/preview)

" Ex-modeでの<C-p><C-n>をzshのヒストリ補完っぽくする
cnoremap <C-p> <Up>
cnoremap <Up>  <C-p>
cnoremap <C-n> <Down>
cnoremap <Down>  <C-n>

" AutoComplPop
" (neocomplcache使用時は無効)
" source ~/dotfiles/.vimrc.autocomplpop

" }}}


"### Tags {{{
"-------------------------------------------------------------------------------
" 解説
"  http://archiva.jp/web/tool/vim_ctags.html#
"  ctagsはMacデフォルトのものは機能不足のため使用しない
"  Homebrewでインストールしたものか、MacVim-Kaoriya付属の物を使用する
"
" 使い方
"  $ ctags *.c
"   カレントディレクトリの*.cファイルからタグファイルを生成
"
"  $ ctags -f ~/.tags -R /home/xxx/
"   「/home/www/」以下の全てのファイルから、「~/.tags」にタグファイルを生成
"   -f 生成ファイルを指定
"   -R 解析対象ディレクトリを指定
"
"  :set tags=~/.tags,/home/user/commontags
"   使用するタグファイルを指定。「,」で複数指定可能
"   .vimrcに記述しておけば、「vim -t tag」で起動時にタグまでジャンプできる
"
" キーバインド
"  C-]     カーソル位置の単語をタグとみなしてジャンプ。
"  C-t     直前のタグに戻る。
"  g C-]   複数候補がある場合に選択→ジャンプ。
"  C-w }   カーソル位置の単語の定義を、プレビューウィンドウで開く。
"  C-w C-z プレビューウィンドウを閉じる。(:pcと同じ)
"
" その他
"  :tselect  現在のタグの一覧を表示
"  :tfirst （タグが重複している場合）最初のタグへ
"  :tn （タグが重複している場合）次のタグへ
"  :tp （タグが重複している場合）前のタグへ
"  :tlast  （タグが重複している場合） 最後のタグへ
"  :tags 移動経路を確認
"  :tag  タグリストの前方にジャンプ。(:3tagなども可)
"  :tag [タグ名] 指定したタグにジャンプ。(:taと同じ)
"  :ptag [タグ名]  [タグ名]の定義をプレビューウィンドウで開く。
"

" set tags
if has("autochdir")
  " 編集しているファイルのディレクトリに自動で移動
  set autochdir
  set tags=tags;
else
  set tags=./tags,./../tags,./*/tags,./../../tags,./../../../tags,./../../../../tags,./../../../../../tags
endif

set notagbsearch

"tab pagesを使い易くする(Vim 7)
nnoremap <C-t>  <Nop>
nnoremap <C-t>n  :<C-u>tabnew<CR>
nnoremap <C-t>c  :<C-u>tabclose<CR>
nnoremap <C-t>o  :<C-u>tabonly<CR>
nnoremap <C-t>j  :<C-u>execute 'tabnext' 1 + (tabpagenr() + v:count1 - 1) % tabpagenr('$')<CR>
nnoremap <C-t>k  gT

"tags-and-searchesを使い易くする
nnoremap t  <Nop>
"「飛ぶ」
nnoremap tt  <C-]>
"「進む」
nnoremap tj  :<C-u>tag<CR>
"「戻る」
nnoremap tk  :<C-u>pop<CR>
"履歴一覧
nnoremap tl  :<C-u>tags<CR>

" }}}


"### Search {{{
"-------------------------------------------------------------------------------
"基本設定
set wrapscan                     " 最後まで検索したら先頭へ戻る
set ignorecase                   " 大文字小文字無視
set smartcase                    " 検索文字列に大文字が含まれている場合は区別して検索する
set noincsearch                  " インクリメンタルサーチ
set hlsearch                     " 検索文字をハイライト

" 検索結果に移動したとき、その位置を画面の中央へ
nnoremap n nzz
nnoremap N Nzz
nnoremap * *zz
nnoremap # #zz
nnoremap g* g*zz
nnoremap g# g#zz


" 外部grepの設定(for grep)
"   -i 大文字小文字を区別しない
"   -n 各行の先頭にファイルの行番号を表示します
"   -H ファイル名を表示
"   -E オプションは、拡張正規表現を使用する場合に指定
"      fgrep 正規表現を使わない検索
"      egrep 正規表現を使った検索 -E と同じ
"   -R ディレクトリを再帰的にたどる
"   -I バイナリ検索除外
set grepprg=grep\ -niE\ $*\ /dev/null

" 外部grepの設定(for ack)
"   -a 全てのファイルから検索(拡張子無しも含む) ただし--TYPEが無効
"   -i 大文字小文字を区別しない
"set grepprg=ack\ -ai

" grepコマンドを改良: Sgrep
"  silent コマンド実行時に表示されるメッセージを抑制
"  grep! 検索後に自動でジャンプしない
command! -nargs=+ Sgrep execute 'silent grep! <args>'


" QuickFixの結果をクリア
"nnoremap <silent> ,qc :cexpr ""<CR>

" q/ESCでQuickFixを閉じる
autocmd FileType qf nnoremap <buffer> q :ccl<CR>
autocmd FileType qf nnoremap <buffer> <ESC> :ccl<CR>

" cwでQuickFixウィンドウの表示をtoggle
function! s:toggle_qf_window()
  for bufnr in range(1,  winnr('$'))
    if getwinvar(bufnr,  '&buftype') ==# 'quickfix'
      execute 'ccl'
      return
    endif
  endfor
  execute 'botright cw'
endfunction
nnoremap <silent> cw :call <SID>toggle_qf_window()<CR>

" QuickFixを自動で開く
autocmd QuickfixCmdPost make,grep,grepadd,vimgrep,Sgrep call s:auto_qf_open()
function! s:auto_qf_open()
  if len(getqflist()) != 0
    execute 'QuickfixStatusEnable'
    execute 'copen'
    " 画面を消去して再描画
    execute 'redraw!'
  endif
endfunction


" 選択した文字列を検索
vnoremap <silent> // y/<C-R>=escape(@", '\\/.*$^~[]')<CR><CR>


" カーソル下の単語で置換
" 1.置換後文字列をヤンク(あれば)  2.置換元単語にカーソルを移動
" 3.s*  4.置換後文字列を編集して
" (ヤンクした文字列を貼り付け : <C-r>")
" (クリップボードから貼り付け : <C-r>+)
nnoremap <expr> s* ':%s/' . expand('<cword>') . '/<C-r>"/gc<Left><Left>'
"nnoremap <expr> ss* ':%s/\<' . expand('<cword>') . '\>/<C-r>"/g'

" 選択した文字列で置換
" 1.置換後文字列をヤンク(あれば)  2.ビジュアルモードで置換元文字列を選択
" 3.s*  4.置換後文字列を編集して実行
" 5./g 入力後に実行
vnoremap s* "vy:%s/\V<C-r>=substitute(escape(@v,'\/'),"\n",'\\n','g')<CR>/<C-r>+/gc<Left><Left>
vnoremap /r "xy:%s/<C-R>=escape(@x, '\\/.*$^~[]')<CR>//gc<Left><Left><Left>

" 選択範囲のみ置換
" 1.置換元文字列をヤンク  2.置換範囲を選択
" 3.sv  4.置換後文字列を手入力
vnoremap sv "vy:%s/\%V<C-r>+//gc<Left><Left><Left><Left>


" ヘルプファイル指定
"set helpfile=$VIMRUNTIME/doc/help.txt
" ヘルプの言語を指定(日本語を優先)
:set helplang=ja,en
" Ctrl-iでヘルプ
nnoremap <C-i>  :<C-u>help<Space>
" カーソル下のキーワードをヘルプでひく
nnoremap <C-i><C-i> :<C-u>help<Space><C-r><C-w><Enter>

" }}}


"### Move {{{
"-------------------------------------------------------------------------------

" カーソルを表示行で移動する。論理行移動は<C-n>,<C-p>
nnoremap h <Left>
nnoremap j gj
nnoremap k gk
nnoremap l <Right>
nnoremap <Down> j
nnoremap <Up>   k

" 0, 9で行頭、行末へ
nmap 1 0
nmap 0 ^
nmap 9 $

" Insertモードのキーバインドをemacs風に
" 行頭/行末へ移動
inoremap  <C-a> <HOME>
inoremap  <C-e> <END>
" C-hjklで移動 - Mac:KeyRemap4MacBookで対応
if ! has('mac')
  inoremap <C-j> <Down>
  inoremap <C-k> <Up>
  inoremap <C-h> <Left>
  inoremap <C-l> <Right>
endif
" Backspace
"  C-q/C-sは端末側で使用されているため stty -ixoff -ixon を実行する必要がある
"  (.bashrcや.zshrcなどに設定する)
"  http://d.hatena.ne.jp/ksmemo/20110214/p1
"  http://www.akamoz.jp/you/uni/shellscript.htm
inoremap  <C-q> <ESC>xi

" Cmdモードのキーバインドをemacs風に
cnoremap  <C-a> <HOME>
cnoremap  <C-e> <END>
cnoremap  <C-q> <BS>

" <space>j, <space>kで画面送り
noremap <Space>j <C-f>
noremap <Space>k <C-b>

" spaceで次のbufferへ。back-spaceで前のbufferへ
"nmap <Space><Space> :MBEbn<CR>
"nmap <BS><BS> :MBEbp<CR>

" F2で前のバッファ
map <F2> <ESC>:bp<CR>
" F3で次のバッファ
map <F3> <ESC>:bn<CR>
" F4でバッファを削除する
map <F4> <ESC>:bnext \| bdelete #<CR>
command! Bw :bnext \| bdelete #

"フレームサイズを怠惰に変更する
map <kPlus> <C-W>+
map <kMinus> <C-W>-

" 前回終了したカーソル行に移動
autocmd BufReadPost * if line("'\"") > 0 && line("'\"") <= line("$") | exe "normal g`\"" | endif

" 最後に編集された位置に移動
nnoremap gb '[
nnoremap gp ']

" 対応する括弧に移動
nnoremap ( %
nnoremap ) %

" 最後に変更されたテキストを選択する
nnoremap gc  `[v`]
vnoremap gc <C-u>normal gc<Enter>
onoremap gc <C-u>normal gc<Enter>

" 矩形選択で自由に移動する
set virtualedit+=block

"ビジュアルモード時vで行末まで選択
vnoremap v $h

" マークジャンプ(前)のキーバインド削除
" screen/tmuxのエスケープキーと重複しているため
nnoremap <C-o>  <Nop>
" マーク一覧表示
nnoremap <Space>m  :<C-u>marks<CR>

" git-diff-aware version of gf commands.
" http://labs.timedia.co.jp/2011/04/git-diff-aware-gf-commands-for-vim.html
nnoremap <expr> gf  <SID>do_git_diff_aware_gf('gf')
nnoremap <expr> gF  <SID>do_git_diff_aware_gf('gF')
nnoremap <expr> <C-w>f  <SID>do_git_diff_aware_gf('<C-w>f')
nnoremap <expr> <C-w><C-f>  <SID>do_git_diff_aware_gf('<C-w><C-f>')
nnoremap <expr> <C-w>F  <SID>do_git_diff_aware_gf('<C-w>F')
nnoremap <expr> <C-w>gf  <SID>do_git_diff_aware_gf('<C-w>gf')
nnoremap <expr> <C-w>gF  <SID>do_git_diff_aware_gf('<C-w>gF')

function! s:do_git_diff_aware_gf(command)
  let target_path = expand('<cfile>')
  if target_path =~# '^[ab]/'  " with a peculiar prefix of git-diff(1)?
    if filereadable(target_path) || isdirectory(target_path)
      return a:command
    else
      " BUGS: Side effect - Cursor position is changed.
      let [_, c] = searchpos('\f\+', 'cenW')
      return c . '|' . 'v' . (len(target_path) - 2 - 1) . 'h' . a:command
    endif
  else
    return a:command
  endif
endfunction

" insert mode でjjでesc
inoremap jj <Esc>


" vimのカレントディレクトリを現在編集中のファイルのディレクトリに変更
" http://vim-users.jp/2009/09/hack69/
command! -nargs=? -complete=dir -bang CD  call s:ChangeCurrentDir('<args>', '<bang>')
function! s:ChangeCurrentDir(directory, bang)
  if a:directory == ''
    lcd %:p:h
  else
    execute 'lcd' . a:directory
  endif

  if a:bang == ''
    pwd
  endif
endfunction

" Change current directory.
nnoremap <silent> <Space>cd :<C-u>CD<CR>

" }}}


"### Edit {{{
"-------------------------------------------------------------------------------

" normalモードでも改行入力可能
" QuickFixでEnterでジャンプができなくなるので不可
"noremap <CR> i<CR><ESC>

"強制全保存終了を無効化。
nnoremap ZZ <Nop>

" レジスタ一覧
nnoremap <Space>r  :<C-u>registers<CR>

" カーソル位置の単語をyankする
nnoremap vy viwy
" カーソル位置の単語をyankした文字に置き換える
nnoremap vp viwpviwy

" yeでそのカーソル位置にある単語をレジスタに追加
nmap <silent>ye :let @"=expand("<cword>")<CR>
" Visualモードでのpで選択範囲をレジスタの内容に置き換える
"vnoremap p <Esc>:let current_reg = @"<CR>gvdi<C-R>=current_reg<CR><ESC>gvy

" Visualモードで選択範囲をレジスタの内容に置き換える
vnoremap zy "zy
vnoremap zp "zp

" ヤンクした文字列でカーソル位置の単語を置換
nnoremap <silent>cy ce<C-r>0<ESC>:let@/=@1<CR>:noh<CR>
vnoremap <silent>cy c<C-r>0<ESC>:let@/=@1<CR>:noh<CR>
nnoremap <silent>ciy ciw<C-r>0<ESC>:let@/=@1<CR>:noh<CR>

" 連続貼り付け
vnoremap <silent> cp "0p<CR>

" コンマの後に自動的にスペースを挿入
"inoremap , ,<Space>
"
" XMLの閉タグを自動挿入
augroup MyXML
  autocmd!
  autocmd Filetype xml inoremap <buffer> </ </<C-x><C-o>
augroup END

" Insert mode中で単語単位/行単位の削除をアンドゥ可能にする
inoremap <C-u>  <C-g>u<C-u>
inoremap <C-w>  <C-g>u<C-w>

" :Ptでインデントモード切替
command! Pt :setlocal paste! | setlocal paste?

" インサートモード中にyankした内容をputする
inoremap <C-o> <ESC>:<C-U>YRPaste 'p'<CR>i

" y9で行末までヤンク
nmap y9 y$
" y0で行頭までヤンク
nmap y0 y^

"
" 括弧を自動補完
"inoremap { {}<LEFT>
"inoremap [ []<LEFT>
"inoremap ( ()<LEFT>
"inoremap " ""<LEFT>
"inoremap ' ''<LEFT>
"vnoremap { "zdi^V{<C-R>z}<ESC>
"vnoremap [ "zdi^V[<C-R>z]<ESC>
"vnoremap ( "zdi^V(<C-R>z)<ESC>
"vnoremap " "zdi^V"<C-R>z^V"<ESC>
"vnoremap ' "zdi'<C-R>z'<ESC>

" 保存時に行末の空白を除去する
autocmd BufWritePre * :%s/\s\+$//ge
" 保存時にtabをスペースに変換する
"autocmd BufWritePre * :%s/\t/  /ge

" 日時の自動入力 (挿入モードで入力)
inoremap <expr> ,df strftime('%Y/%m/%d %H:%M:%S')
inoremap <expr> ,dd strftime('%Y/%m/%d')
inoremap <expr> ,dt strftime('%H:%M:%S')

" <leader>j でJSONをformat
" http://wozozo.hatenablog.com/entry/2012/02/08/121504
map <Leader>j !python -m json.tool<CR>


" 線を引く (挿入モードで入力)
inoremap <expr> ,r* repeat('*', 80 - col('.'))
inoremap <expr> ,r# repeat('#', 80 - col('.'))
inoremap <expr> ,r+ repeat('+', 80 - col('.'))
inoremap <expr> ,r- repeat('-', 80 - col('.'))
inoremap <expr> ,r= repeat('=', 80 - col('.'))

" }}}


"### Encoding {{{
"-------------------------------------------------------------------------------
"  http://d.hatena.ne.jp/ka-nacht/20080220/1203433500
"  http://www.kawaz.jp/pukiwiki/?vim#cb691f26
"  http://d.hatena.ne.jp/over80/20080907/1220794834
"
"  encoding
"   vim内部で使用する文字コード
"   バッファ/レジスタ/vimスクリプトなどの文字列に適用される
"   vim全体で共通のグローバルオプション
"   新規ファイル作成時にfileencodingが未指定の場合にも使用される
"
"  fileencoding
"   新規ファイル作成時またはバッファ保存時に使用される文字コード
"   (ファイルの文字コードと言えばこの値を指す)
"   バッファ毎に指定可能なバッファローカルオプション
"   encodingと異なる場合は保存時にfileencodingへ変換される
"   fileencodingを変更したい場合は setlocal にて変更する必要がある
"   set にて変更した場合はグローバル値が変更されるため、以降に新規作成される
"   バッファの保存時に適用される文字コードが変わってしまう
"
"  fileencodings
"   文字コードの自動判別優先順位
"   カンマ区切りで指定され、左側の設定が優先される
"   判別方法は左から順に変換を行い最初に成功した値が適用される
"   変換途中にencodingまたはfileencodingと同じ値を発見した場合は判定を中断し
"   その値を適用する
"   自動判別に失敗した場合は encoding の値が適用される
"
"  fileformat
"   改行コード(unix=LF, dos=CRLF, mac=CR)
"
"  fileformats
"   改行コードの自動判別優先順位
"

set encoding=utf-8
set fileformats=unix,dos,mac

" □や◯文字があってもカーソル位置がずれないように
" Win版Kaoriyaではautoが使用可能
if &ambiwidth !=# 'auto'
  set ambiwidth=double
endif

if has("kaoriya")
  " Kaoriya版ではguess指定で独自の自動判別が可能
  set fileencodings=guess,ucs-bom,iso-2022-jp-3,iso-2022-jp,eucjp-ms,euc-jisx0213,euc-jp,sjis,cp932,utf-8
endif
" Kaoriya版以外では banyan/recognize_charcode.vim にて文字コードを判定
" https://github.com/banyan/recognize_charcode.vim


" ワイルドカードで表示するときに優先度を低くする拡張子
set suffixes=.bk,.bak,~,.swp,.o,.info,.aux,.log,.dvi,.bbl,.blg,.brf,.cb,.ind,.idx,.ilg,.inx,.out,.toc

" 指定文字コードで強制的にファイルを開く
"  -bang !付きで実行可能
command! -bang -nargs=? Cp932 edit<bang> ++enc=cp932 <args>
command! -bang -nargs=? Eucjp edit<bang> ++enc=euc-jp <args>
command! -bang -nargs=? Iso2022jp edit<bang> ++enc=iso-2022-jp <args>
command! -bang -nargs=? Utf8 edit<bang> ++enc=utf-8 <args>
command! Jis Iso2022jp
command! Sjis Cp932

" }}}


"### Misc {{{
"-------------------------------------------------------------------------------
"### KeyMap on Mac
if has("mac")
  " 編集中のファイルをブラウザ(Chrome)で開く(Mac Only)
  "  %:p 現在編集中のファイルの絶対パス
  command! OB :silent call s:open_browser()
  function! s:open_browser()
    try
      execute '!open -a Google\ Chrome %:p'
    finally
      " 画面を消去して再描画
      execute 'redraw!'
    endtry
  endfunction

  " MarkdownをMarked.appで開く
  :nnoremap <leader>om :silent !open -a Marked.app '%:p'<cr>:redraw!<cr>
endif


"### Default Skeleton File
augroup SkeletonAu
  autocmd!
  autocmd BufNewFile *.html 0r $HOME/.vim/my_templates/skel.html
  autocmd BufNewFile *.sh 0r $HOME/.vim/my_templates/skel.sh
  autocmd BufNewFile *.py 0r $HOME/.vim/my_templates/skel.py
  autocmd BufNewFile *.user.js 0r $HOME/.vim/my_templates/skel.user.js
augroup END


" insertモードを抜けるとIMEオフ
" Mac では KeyRemap4MacBook にて対応
"  http://d.hatena.ne.jp/r7kamura/20110217/1297910068
if ! has('mac')
  set noimdisable               " IMを無効化
  " im***=n
  "   0:日本語モード(Input Method)OFF
  "   1:lmapをONにしてIMをOFFにする
  "   2:lmapをOFFにしてIMをONにする
  set iminsert=0                " 入力モードで日本語入力OFF
  set imsearch=0                " 検索モードで日本語入力OFF
  set noimcmdline               " コマンドラインで日本語入力OFF
endif

" ESC後のモード表示の即時反映(msec)
"   http://gajumaru.ddo.jp/wordpress/?p=1076
"   http://gajumaru.ddo.jp/wordpress/?p=1101
"   http://yakinikunotare.boo.jp/orebase2/vim/dont_work_arrow_keys_in_insert_mode
"   https://sites.google.com/site/fudist/Home/vim-nihongo-ban/vim-japanese/ime-control/ibus
"   https://sites.google.com/site/fudist/Home/vim-nihongo-ban/vim-japanese/ime-control/ctrl-hat
set timeout timeoutlen=1000 ttimeoutlen=75

" Escの2回押し
"   検索ハイライト消去
"   vim-hierのハイライト消去
nmap <silent><ESC><ESC> :nohlsearch<CR>:HierClear<CR>:redraw!<CR><ESC>

" 補完中にESCで補完キャンセル
"inoremap <silent><expr><ESC> pumvisible() ? neocomplcache#cancel_popup()."<ESC>" : "<ESC>"

" }}}


" vim: fdm=marker fen fdl=0
